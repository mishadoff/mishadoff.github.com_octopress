<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2013-01-25T17:47:43+02:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 013]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-013/"/>
    <updated>2013-01-25T16:33:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-013</id>
    <content type="html"><![CDATA[<blockquote><p>Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=13">http://projecteuler.net/problem=13</a></p>

<!-- more -->


<p><em>Assume, here is a huge amount of digits. In any case, you can always find them in permalink.</em></p>

<p>What is the problem to sum one-hundred numbers?</p>

<p><code>clojure
(reduce + numbers)
</code></p>

<p>Done.</p>

<p>Are you kidding me? Not so fast. The question is <em>what type of number you must choose</em>
to sum all these numbers. <code>int</code>? <code>long</code>? <code>looooong</code>? <code>super long long</code>?</p>

<p>Technique to sum very long numbers called
<a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic">Bignum arithmetic</a>.
To solve that problem you just need to implement this technique... or use already implemented.</p>

<p>Java (<em>yeah we talking about it</em>) support long arithmetics with
<a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html">BigInteger</a>.
And clojure does.</p>

<p><code>clojure
(reduce + (map bigint numbers))
</code></p>

<p>With that function you'll get the big number.
Just truncate first 10 digits and you are good.</p>

<p><code>clojure
(apply str (take 10 (str (reduce + (map bigint numbers)))))
</code></p>

<p>(for [i "<a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem013.clj">GitHub</a>"] i)</p>

<p><strong>P.S.</strong> Ideally, last line should be wrapped
with <code>(read-string ...)</code> to produce number type. But we using
manual submission, so it is fair.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 012]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-012/"/>
    <updated>2013-01-22T19:45:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-012</id>
    <content type="html"><![CDATA[<blockquote><p>What is the value of the first triangle number to have over five hundred divisors?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=12">http://projecteuler.net/problem=12</a></p>

<!-- more -->


<blockquote><p>The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.</p>

<p>The first ten terms would be:</p>

<p>1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...</p>

<p>Let us list the factors of the first seven triangle numbers:</p></blockquote>

<pre><code> 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
</code></pre>

<blockquote><p>We can see that 28 is the first triangle number to have over five divisors.</p>

<p>What is the value of the first triangle number to have over five hundred divisors?</p></blockquote>

<p>When we see infinite sequence of some numbers, first thing that we do is implement it
with using <em>lazy sequences</em>. Simple explanation and example for Fibonacci numbers
can be found in <a href="/blog/clojure-euler-problem-002">Clojure Euler: Problem 002</a>.</p>

<p>We have an easy case, so we implement triangle number as
sum of all integers below:</p>

<p><code>clojure
(defn triangle-number [n]
  (reduce + (range 1 (inc n))))
</code></p>

<p>Don't miss the possibility reduce complexity from <code>O(n)</code> to <code>O(1)</code>.
Just apply <a href="http://en.wikipedia.org/wiki/Arithmetic_progression">arithmetic progression</a> formula.</p>

<p><code>clojure
(defn triangle-number [n]
  (* n (/ (+ n 1) 2)))
</code></p>

<p>Okey, we did small optimization (<em>not so small</em>) here and we have a function that calculates
triangle number for <code>n</code>. Let's find all of them!</p>

<p><code>clojure
(def triangles (map triangle-number (iterate inc 1)))
</code></p>

<p><code>triangles</code> refers to lazy sequence of <em>triangle numbers</em>.</p>

<blockquote><p>Do not evaluate lazy seqs!</p></blockquote>

<p>Use limit functions as <code>take</code>, <code>take-while</code>, <code>drop</code>, <code>drop-while</code> to test the
sequence values, or build other lazy seqs with <code>filter</code>, <code>map</code>, etc.</p>

<p>Now, we need a function to calculate number of divisors.</p>

<p><code>clojure
(defn num-of-divisors [n]
  (* 2 (count (filter #(= (mod n %) 0) (range 2 (inc (int (sqrt n))))))))
</code></p>

<p>If we remember <a href="/blog/clojure-euler-problem-003">Clojure Euler: Problem 003</a>
then we know that using <code>sqrt(n)</code> instead of <code>n</code> as upper bound for divisors
saves much time.
Don't forget mutiply that value by two, as you skip number after <code>sqrt(n)</code>.</p>

<p>Last step: to calculate number over 500 divisors</p>

<p><code>clojure
(first (drop-while #(&lt; (num-of-divisors %) 500) triangles))
</code></p>

<p>We got the result, but spent ~11 secs. Too much.</p>

<p><em>How can we improve our solution?</em></p>

<p>There is theorem about
<a href="http://en.wikipedia.org/wiki/Integer_factorization#Prime_decomposition">Prime Factorization</a>
states:</p>

<blockquote><p>Every positive integer has a unique prime factorization</p></blockquote>

<p>For example: 15 = 3<sup>1</sup> * 5<sup>1,</sup> 18 = 2<sup>1</sup> * 3<sup>2</sup> and so on.</p>

<p>Not hard to see that number of divisors from such factorization can be obtained
by multiplying all prime powers incremented by one.</p>

<p>For example number 18 have 6 divisors (1, 2, 3, 6, 9, 18).
If we take factorization 18 = 3<sup>1</sup> * 5<sup>1,</sup> then number of divisors is
equal to (1 + 1) * (2 + 1) = 6. You see, the same.
Not hard to prove this theorem or
<a href="http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic#Proof">read the proof</a>.</p>

<p>Stop math, we need to code, so let's code that.</p>

<p>First of all, we need factorization method:</p>

<p>``` clojure
(defn factorize [n]
  (loop [x n [p &amp; ps] primes factors []]</p>

<pre><code>(cond (= 1 x) factors
      (zero? (mod x p)) (recur (/ x p) primes (conj factors p))
      :else (recur x ps factors))))
</code></pre>

<p>```</p>

<p>It uses <code>primes</code> from <code>clojure.contrib.lazy-seqs</code>.
This method prints all factors (<em>including duplicates</em>) for <code>n</code>.</p>

<p>For example:</p>

<p><code>clojure
(factorize 18) =&gt; [2 3 3]
</code></p>

<p>But instead of actual values of divisors, we just need their count.</p>

<p><code>clojure
(defn factorize-count [n]
  (reduce * (map (comp inc count) (vals (group-by identity (factorize n))))))
</code></p>

<p>Calculate the result again:</p>

<p><code>clojure
(first (drop-while #(&lt; (factorize-count %) 500) triangles))
</code></p>

<p>Bingo! It gives the correct result in less than 3 seconds.
Not bad as improvement.</p>

<p>{:code "<a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem012.clj">GitHub</a>"}</p>

<p><strong>P.S.</strong> If you test-addicted person, you, probably, point out
that function <code>num-of-divisors</code> yields incorrect result for input <code>1</code>.
We can live with that, because our needed number is much greater than 1.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 011]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-011/"/>
    <updated>2013-01-18T13:45:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-011</id>
    <content type="html"><![CDATA[<blockquote><p>What is the greatest product of four adjacent numbers in the same
direction (up, down, left, right, or diagonally) in the 20 x 20 grid?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=11">http://projecteuler.net/problem=11</a></p>

<!-- more -->


<blockquote><p>In the 20 x 20 grid below, four numbers along a diagonal
line have been enclosed into square brackets</p></blockquote>

<pre><code>08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08
49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00
81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65
52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91
22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80
24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50
32 98 81 28 64 23 67 10[26]38 40 67 59 54 70 66 18 38 64 70
67 26 20 68 02 62 12 20 95[63]94 39 63 08 40 91 66 49 94 21
24 55 58 05 66 73 99 26 97 17[78]78 96 83 14 88 34 89 63 72
21 36 23 09 75 00 76 44 20 45 35[14]00 61 33 97 34 31 33 95
78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92
16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57
86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58
19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40
04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66
88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69
04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36
20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16
20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54
01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48
</code></pre>

<blockquote><p>The product of these numbers is 26 * 63 * 78 * 14 = 1788696.</p>

<p>What is the greatest product of four adjacent numbers in the
same direction (up, down, left, right, or diagonally) in the 20 x 20 grid?</p></blockquote>

<p>First step is pretty routine, we need to create such grid representation
in our program from file. For the way how we read files refer
<a href="/blog/clojure-euler-problem-008">Clojure Euler: Problem 008</a>, we have
similar problem there.</p>

<p>``` clojure
(defn get-matrix []
  (map #(Integer/parseInt (apply str %))</p>

<pre><code>   (partition 2 2 (remove #(or (= \newline %) (= \ %))
                          (seq (slurp "res/problem011.txt"))))))
</code></pre>

<p>```</p>

<p>Idea is following: read the file, drop the garbage,
take all two-digit combinations, concat each and transform to the integer.</p>

<p>To make things simple we reading the numbers in one-dimensional list
of size 20 x 20 = 400. We always can use formula to represent two dimensional
indexing for one-dimensional array and vice versa.</p>

<p><em>Example:</em> suppose you need a 3 x 3 matrix <code>A</code></p>

<pre><code>9    2    4
6    1    7
5    3    8
</code></pre>

<p>You can flat it into 1D array <code>B</code></p>

<pre><code>9 2 4 6 1 7 5 3 8
</code></pre>

<p>Now, when you want <code>A[i][j]</code> use the formula <code>i * size_j + j</code>, where <code>size_j</code>
is second matrix dimension. Therefore <code>A[1][2] = B[1 * 3 + 2] = B[5] = 7</code>, what is correct.</p>

<p>Implementing that in clojure gives one indexing function</p>

<p>``` clojure
(defn get-at [i j matrix]
  (if (and (>= i 0) (&lt; i 20) (>= j 0) (&lt; j 20))</p>

<pre><code>(nth matrix (+ j (* i 20))) 0))
</code></pre>

<p>```</p>

<p>We check the boundaries of array inside this function, which can be inappropriate
in many cases, but it is good as we use it in one place.</p>

<p>Ok. We have data, we have methods operate this data, now let's code logic.
Our good friend - <strong>bruteforce</strong>.</p>

<p>``` clojure
(let [matrix (get-matrix)</p>

<pre><code>  ways (for [i (range 20) j (range 20)]
         [(map #(get-at i (+ % j) matrix) (range 4))
          (map #(get-at (+ % i) j matrix) (range 4))
          (map #(get-at (+ % i) (+ % j) matrix) (range 4))
          (map #(get-at (+ % i) (- j %) matrix) (range 4))])]
(reduce max (map #(reduce * %) (reduce concat ways))))
</code></pre>

<p>```</p>

<p>We iterate on all matrix elements as start of 4-element range.</p>

<p>We have 4 conditions, each of them represents some direction.
All these 4 directions represent all possible direction in grid.</p>

<ol>
<li>NORTH -> SOUTH (Up &amp; Down covered)</li>
<li>WEST -> EAST (Left &amp; Right covered)</li>
<li>NW -> SE (backslash diagonals covered)</li>
<li>NE -> SW (slash diagonals covered)</li>
</ol>


<p>```</p>

<pre><code>S      S * * *         S                  S
*                       *                *
*                        *              *
*                         *            *
</code></pre>

<p>```</p>

<p><em>S is for start</em></p>

<p>If we obtain all possible 4-element ranges for matrix, just find
maximum of product.</p>

<p>Problem solved!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem011.clj">github</a></p>

<p><strong>P.S.</strong> Boring problem.
I think it just for introducing matrices computation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 010]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-010/"/>
    <updated>2012-12-15T00:23:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-010</id>
    <content type="html"><![CDATA[<blockquote><p>The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.</p>

<p>Find the sum of all the primes below two million.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=10">http://projecteuler.net/problem=10</a></p>

<!-- more -->


<p>We have already worked with prime numbers in
<a href="/blog/clojure-euler-problem-003/">Problem 003</a> and
<a href="/blog/clojure-euler-problem-007/">Problem 007</a>. We also decided that
the best way to work with prime numbers in clojure to use <code>primes</code> lazy-seq
from <code>clojure.contrib.lazy-seqs</code>.</p>

<p>Gentle reminder: Just add proper <code>:use</code> to your file:</p>

<p><code>clojure
(:use [clojure.contrib.lazy-seqs :only (primes)])
</code></p>

<p>Then, the simplest problem solution to use <code>take-while</code> stream and <code>reduce</code> for sum:</p>

<p><code>clojure
(reduce + (take-while #(&lt; % 2000000) primes))
</code></p>

<p>Again, one-line solution. Let's run it.</p>

<p>Finding result on my nachine takes ~12 seconds. Small enough, but maybe somehow it can be improved?</p>

<h3>Sieve of Eratosthenes</h3>

<p><a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a> - ancient algorithm
for finding prime numbers. The best explanation how it works with picture from wiki:</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="" /></p>

<p>Our first naive implementation:</p>

<p>```clojure
(defn sieve-1 []
  (loop [nums (set (cons 2 (range 3 2000000 2))) n 3]</p>

<pre><code>(if (&gt; n 2000000) (reduce + nums)
    (recur (clojure.set/difference nums (set (range (* n n) 2000000 n))) (inc n)))))
</code></pre>

<p>```</p>

<p><em>Note:</em> <a href="http://clojuredocs.org/clojure_core/clojure.set/difference">clojure.set/difference</a> function
find the difference between two sets.</p>

<p>This recursive implementation is even worse than our oneliner, it calculates the result in ~24 seconds.</p>

<p>Primary optimisation is to use <code>(* n n)</code> as recursion base instead of <code>n</code>. Because of there are no prime
numbers if we crossed greater than square root of maximum. Problem evolves.</p>

<p>``` clojure
(defn sieve-2 []
  (loop [nums (set (cons 2 (range 3 2000000 2))) n 3]</p>

<pre><code>(if (&gt; (* n n) 2000000) (reduce + nums)
    (recur (clojure.set/difference nums (set (range (* n n) 2000000 n))) (inc n)))))
</code></pre>

<p>```</p>

<p>~21 seconds. Still worse.</p>

<p>Why we increment by 1 on recursion call? If we starting our <code>n</code> value from <code>3</code> we don't need
to go over even numbers.</p>

<p>```clojure
(defn sieve-3 []
  (loop [nums (set (cons 2 (range 3 2000000 2))) n 3]</p>

<pre><code>(if (&gt; (* n n) 2000000) (reduce + nums)
    (recur (clojure.set/difference nums (set (range (* n n) 2000000 n))) (+ n 2)))))
</code></pre>

<p>```</p>

<p>~13 seconds. Much better... than previous, still worse than first version.</p>

<p>If you looked at <code>difference</code> documentation, take a look at its implementation under "Source".
Nothing prevent us to pass sequence as second argument instead of set. Just removing casting to set.</p>

<p>``` clojure
(defn sieve-4 []
  (loop [nums (set (cons 2 (range 3 2000000 2))) n 3]</p>

<pre><code>(if (&gt; (* n n) 2000000) (reduce + nums)
    (recur (clojure.set/difference nums (range (* n n) 2000000 n)) (+ n 2)))))
</code></pre>

<p>```</p>

<p>~6 seconds. Wow! It's better than original solution. That means our efforts were not wasteful.</p>

<p>Unfortuantely, we stopped improve our function. But if you want more, other major improvements
can be done in the following areas:</p>

<ul>
<li>Use non-persistent set to save prime numbers. It prevent overhead on new objects.</li>
<li>Use "wheel trick" that can be found in the sources of <code>primes</code> from <code>clojure.contrib.lazy-seqs</code>.</li>
<li>Use dynamic step of iteration. We changed <code>(inc n)</code> to <code>(+ n 2)</code>, but probably there is smarter solution.</li>
<li>Do not use <code>(reduce +)</code> because it is linear algorithm. We init <code>nums</code> sequence with some arithmetic progression.
Its sum can be calculated in O(1) by formula. When we compose another sequence (second argument for <code>difference</code>)
its also an arithmetic progression and sum can be calculated in O(1). When doing differencem just subtract second sum
from first sum, and it will be current <code>nums</code> sum.</li>
</ul>


<p>There are much more optimisations can be done to improve prime numbers performace.
If you interested, read nice Christophe Grand's post
<a href="http://clj-me.cgrand.net/2009/07/30/everybody-loves-the-sieve-of-eratosthenes/">Everybody Loves The Sieve Of Erathosthenes</a></p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem010.clj">(str "Git" "Hub")</a></p>

<p><strong>P.S</strong> Honestly, I am OK with 12 seconds. But 6 seconds is better. We performed improvements
just to show the point <strong>if you want to improve something, probably, you can do it</strong>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 009]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-009/"/>
    <updated>2012-12-11T17:41:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-009</id>
    <content type="html"><![CDATA[<blockquote><p> A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which, a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></p>

<p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup></p>

<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=9">http://projecteuler.net/problem=9</a></p>

<!-- more -->


<p>Thinking about clever way to solve it...</p>

<p>Nothing good came up in your mind? Try bruteforce.</p>

<p>Again, the idea behind bruteforce for this problem to iterate over all possible values
for <code>a</code>, <code>b</code> and <code>c</code>, that sums to <code>1000</code> and compose Pythagorean triplet.
That's why we need predicate to test if three numbers compose triplet:</p>

<p><code>clojure
(defn is-triplet? [a b c]
  (= (+ (* a a) (* b b)) (* c c)))
</code></p>

<p>Then our bruteforce solution looks like this:</p>

<p>``` clojure
(first (for [a (range 1 1000) b (range 1 1000) c (range 1 1000)</p>

<pre><code>         :when (and (is-triplet? a b c) (= (+ a b c) 1000))] (* a b c)))
</code></pre>

<p>```</p>

<p>It finds the right solution, in ~45 seconds. Bad enough.</p>

<h3>Trick #1</h3>

<p>Do not iterate on <code>c</code> variable, because knowing <code>a</code> and <code>b</code> we always
can calculate <code>c = 1000 - a - b</code>.</p>

<p>Problem solution transformed into next one:</p>

<p>``` clojure
(first (for [a (range 1 1000) b (range 1 1000)</p>

<pre><code>         :let [c (- 1000 a b)]
         :when (is-triplet? a b c)] (* a b c)))
</code></pre>

<p>```</p>

<h3>Trick #2</h3>

<p>Use rule <code>a &lt; b &lt; c</code> from problem definition. Then our iteration will be:</p>

<p><code>clojure
(for [a (range 1 1000) b (range a (- 1000 a))])
</code></p>

<h3>Trick #3</h3>

<p><code>is-triplet?</code> predicate use 3 multiplications, addition and comparison.
We can add to <code>:when</code> section, predicate that compare <code>c</code> to <code>b</code>. This is also
slightly reduce number of <code>is-triplet?</code> execution.</p>

<p><code>clojure
:when (and (&gt; c b) (is-triplet? a b c))
</code></p>

<p>Now solution found in ~45 msecs. 1000 times faster. Not bad.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem009.clj">(apply str (reverse "buHtiG"))</a></p>

<p><strong>P.S.</strong> Unfortunately, there was nothing in this problem about new clojure
functions, programming and even problem was not challenging. But you see the way how
we solve it. We tried "bad" approach with knowing about all its disadvantages.
One more step and we improved it and got right solution. So it is not that bad
approach to try simple solution, even if it is wrong.</p>
]]></content>
  </entry>
  
</feed>
