<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2013-07-06T16:00:21+03:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fast Factorial]]></title>
    <link href="http://mishadoff.github.com/blog/fast-factorial/"/>
    <updated>2013-06-07T01:08:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/fast-factorial</id>
    <content type="html"><![CDATA[<p>Factorial function is simple enough. But there is still some fun about it.
In <a href="/blog/stirlings-approximation/">Stirling’s Approximation</a> article
we’ve seen how to calculate good factorial approximation faster than <em>exact</em> value.
By the way, there is an algorithm to calculate <em>exact</em> value of factorial faster
than “by definition”.</p>

<!-- more -->

<h3 id="factorials">Factorials</h3>

<p>Most of programming languages tutorials shows the following
approach to calculate factorial (<em>transformed to clojure</em>):</p>

<p><code>clojure
(defn factorial [n]
  (if (zero? n) 1
      (* n (factorial (dec n)))))
</code></p>

<p>Simple recursive solution.</p>

<p><em>Note:</em> Since clojure allows using <code>!</code> character in function name, it is good name for factorial.</p>

<p><code>(! 10)</code> works, <code>(! 20)</code> works, <code>(! 30)</code>…</p>

<p><code>
&gt; ArithmeticException integer overflow
</code></p>

<p>Oops.</p>

<p>Default clojure integer type is 64 bit (<code>Long</code>).
It does not fit well for <em>such large input</em>, so we rewrite function.</p>

<p><code>clojure
(defn ! [n]
  (if (zero? n) 1
      (*' n (! (dec n)))))
</code></p>

<p>Just one character added, <code>*</code> became <code>*'</code>. It is automatic type promotion.
If type can not hold the value without losing precision, it automatically extends.
In this case, <code>Long</code> becames <code>BigInteger</code> and all works fine.</p>

<p><code>(! 30)</code> works, <code>(! 300)</code> works, <code>(! 3000)</code> works,
<code>(! 30000)</code>…</p>

<p><code>
&gt; StackOverflowError
</code></p>

<p>Yet another overflow.</p>

<p>Well, stack size is limited. We don’t need to consume stackframes and
will use <code>loop/recur</code> approach.</p>

<p><code>clojure
(defn ! [n]
  (loop [cur n acc 1]
    (if (zero? cur) acc
        (recur (dec cur) (*' cur acc)))))
</code></p>

<p>It is also recursive approach, but instead of saving so far calculated value
in stack, we pass it to the function as a parameter.
Clojure optimize tail recursion to iterative version and does not consume stack.
It succesfully calculates factorial for 30000,
and for any other value. Great!</p>

<p>If we look at the factorial as a calculation process, not definition, it means
“product of all numbers between 1 and n”. It is very concise for functional programming:</p>

<p><code>clojure
(defn ! [n]
  (reduce *' (range 1 (inc n))))
</code></p>

<p>Does not consume stack, no number overflow, but works
~2 times slower than <code>loop/recur</code> version.</p>

<p>I don’t know the reason, but it seems time wasted
by <code>reduce</code> for creating intermediate results. So we choose
previous <code>loop/recur</code> function as baseline factorial.</p>

<h3 id="fast-factorial">Fast Factorial</h3>

<p>Here is another way to calculate factorial.</p>

<p>Let’s consider example <code>12!</code>.</p>

<p>Factorial is a product of numbers <code>12! = 1 * 2 * 3 * ... * 11 * 12</code>.
Perform prime factorization of each number.
For example, prime factorization of <code>12</code> is <code>2 * 2 * 3</code>.</p>

<p>After that we get a factorization of the <code>12!</code>, which contains only prime numbers.
To find factorial value we can just multiply them all. But we do clever trick instead.</p>

<p>Group every prime number and its power.
E.g. if we have factorization <code>2 * 2 * 2 * 3 * 5</code> it becomes vector of pairs <code>[[2 3] [3 1] [5 1]]</code>.</p>

<p>To calculate power we have simple <code>power</code> implementation:</p>

<p><code>clojure
(defn power [x n]
  (reduce *' (repeat n x)))
</code></p>

<p>Trick is using exponentiation by squaring, which reduce
exponentiation complexity from <code>O(n)</code> to <code>O(log n)</code>.</p>

<p><code>clojure
(defn power [x n]
  (cond (= 0 n) 1
        (= 1 n) x
        (even? n) (power* (*' x x) (/ n 2))
        (odd? n) (*' x (power* (*' x x) (/ (dec n) 2)))))
</code></p>

<p>It is not tail-recursive solution and theoretically may cause
stackoverflow, but its not critical. It works well for large numbers.</p>

<p>Actually, we do not perform factorization. We just know that factorization of <code>n!</code> contains all prime numbers below or equal <code>n</code> and every number have some multiplicity. </p>

<p>The function calculates how many times prime number <code>k</code> occurs in factorial factorization for <code>n</code></p>

<p><code>clojure
(defn- find-power [n k]
  (loop [total n sum 0]
    (let [i (int (/ total k))]
      (if (zero? i) sum
          (recur i (+ sum i))))))
</code></p>

<p>Binding all together:</p>

<p><code>clojure
(defn !! [n]
  (loop [[h &amp; t] 
         (map #(power % (find-power n %))
              (take-while #(&lt;= % n) (primes)))
         acc 1]
    (if h (recur t (*' h acc)) acc)))
</code></p>

<p><a href="https://github.com/mishadoff/numberto/blob/master/src/numberto/factorial.clj">Code available here</a></p>

<p><em>Note:</em> <code>primes</code> is a function generates lazy-sequence of prime numbers. It can be taken from <code>clojure.contrib.lazy-seqs</code>.</p>

<h3 id="testing">Testing</h3>

<blockquote>
  <p>Anyway, why do you think it is faster?
You performing more calculations than just multiplying numbers.</p>
</blockquote>

<p>Let’s see.</p>

<p><code>clojure
(do (println "== 10 ==")
    (time (! 10))
    (time (!! 10))
    (println "== 100 ==")
    (time (! 100))
    (time (!! 100))
    (println "== 1000 ==")
    (time (! 1000))
    (time (!! 1000))
    (println "== 10000 ==")
    (time (! 10000))
    (time (!! 10000))
    (println "== 100000 ==")
    (time (! 100000))
    (time (!! 100000))
    (println "== 1000000 ==")
    (time (! 1000000))
    (time (!! 1000000)) nil)
</code></p>

<p><code>
== 10 ==
"Elapsed time: 0.051054 msecs"
"Elapsed time: 0.137587 msecs"
== 100 ==
"Elapsed time: 0.081365 msecs"
"Elapsed time: 0.376653 msecs"
== 1000 ==
"Elapsed time: 1.59252 msecs"
"Elapsed time: 3.212842 msecs"
== 10000 ==
"Elapsed time: 161.856965 msecs"
"Elapsed time: 76.452529 msecs"
== 100000 ==
"Elapsed time: 19403.375319 msecs"
"Elapsed time: 6372.35266 msecs"
== 1000000 ==
"Elapsed time: 2863893.471718 msecs"
"Elapsed time: 1079632.255919 msecs"
nil
</code></p>

<p>For small factorials <code>(&lt; 1000)</code> improved version works ~2 times slower.
Around the thousand it has the same performance as standard version.
And, finally, some win (up to 3 times) for larger numbers.</p>

<p>Theoretically, you can implement generalized factorial with these two algorithms
and switch between them, depending on input. But who really need it? </p>

<blockquote>
  <p>Question: What the complexity of this algorithm?</p>
</blockquote>

<p><strong>P.S.</strong> Enterprise lovers would say factorial complexity is <code>O(1)</code>.
Just precompute all values and save them to database.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 018]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-018/"/>
    <updated>2013-05-17T00:26:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-018</id>
    <content type="html"><![CDATA[<blockquote>
  <p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p>
</blockquote>

<p><code>
       3
      7 4
     2 4 6
    8 5 9 3
</code></p>

<blockquote>
  <p>That is, 3 + 7 + 4 + 9 = 23.</p>

  <p>Find the maximum total from top to bottom of the triangle below:</p>

  <p>[Check out big triangle in original link]</p>

  <p>NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route.
However, Problem 67, is the same challenge with a triangle containing one-hundred rows;
it cannot be solved by brute force, and requires a clever method! ;o)</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=18">http://projecteuler.net/problem=18</a></p>

<!-- more -->

<p>As note says we can try every route and it will be just good.
Instead of that, we can behave much better with clever method.</p>

<p>(Some time ago, I gave basic explanation on my approach in <a href="http://stackoverflow.com/questions/8002252/euler-project-18-approach">StackOverflow question</a>)</p>

<p>We have example triangle:</p>

<p><code>
       3
      7 4
     2 4 6
    8 5 9 3
</code></p>

<p>Instead of testing each route from top to the bottom, we moving from bottom
to the top and always select the best choice. As we want to find the max sum, we perform addition im place.</p>

<p>Assuming we on the 3rd line (2 4 6).</p>

<p><strong>From 2</strong> we can go either 8 or 5, 8 is better (maximize your sum), then you calculate first
sum <code>8 + 2 = 10</code>.</p>

<p><strong>From 4</strong> we can go either 5 or 9, 9 is better, <code>4 + 9 = 13</code>.</p>

<p><strong>From 6</strong> we can go either 9 or 3, 9 is better, <code>9 + 6 = 15</code>.</p>

<p>Now, we removing last row, because we processed all routes and selected best ones, and replacing
3rd row with calculated sums. Current triangle looks like:</p>

<p><code>
        3
      7  4
    10 13 15
</code></p>

<p>Repeat the same action until we get one number, which will be solution.</p>

<p>Let’s transform this idea to clojure.</p>

<p>First of all we need datastructure to represent triangle.
List of lists would be good:</p>

<p><code>clojure
(def triangle '((3) (7 4) (2 4 6) (8 5 9 3)))
</code></p>

<p>Now we want to know, what direction generates the best sum.</p>

<p><code>clojure
(defn max-row [lst]
  (map #(reduce max %) (partition 2 1 lst)))
</code></p>

<p>It breaks list to pairs, and select max from each pair.
For example, <code>[8 5 9 3]</code> we split to <code>[[8 5] [5 9] [9 3]]</code>
and select max from each sublist <code>[8 9 9]</code>.</p>

<p>Just add this list to previous one</p>

<p><code>clojure
(defn step-max [lst1 lst2]
  (map + (max-row lst1) lst2))
</code></p>

<p>One iteration of <code>step-max</code> creates smaller triangle with sums on the bottom row.
But we need only one number.</p>

<p>Correct, <code>reduce</code> is ideal!</p>

<p><code>clojure
(reduce step-max (reverse triangle))
</code></p>

<p>That’s it.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem018.clj">code</a></p>

<p><strong>P.S.</strong> Problem 067 can be solved with the same code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 017]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-017/"/>
    <updated>2013-04-09T21:13:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-017</id>
    <content type="html"><![CDATA[<blockquote>
  <p>If the numbers 1 to 5 are written out in words: one, two, three, four, five,
then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p>

  <p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=17">http://projecteuler.net/problem=17</a></p>

<!-- more -->

<p>To solve this problem we need some sort of mapping that defines association
between number and its string representation, e.g <code>123 = one hundred and twenty three</code>.</p>

<p>This can be done with maps in clojure in form <code>{:1 "one" :2 "two"}</code>.
But if pay more atention to this map, we see that key is a numeric value.
Exactly what plain arrays do.</p>

<p>Then we just define all mappings, obtain all arrays string elements, find their lengths and sum them.</p>

<p>One problem that providing mapping for each number between 1 and 1000 is a “bit” routine task, so we
need some formula to calculate representation instead of hardcoding it. We come to defining groups.</p>

<p>First group is just <em>first 20</em> numbers:</p>

<p><code>clojure
(def first20 ["one" "two" "three" "four" "five"
              "six" "seven" "eight" "nine" "ten"
              "eleven" "twelve" "thirteen" "fourteen" "fifteen"
              "sixteen" "seventeen" "eighteen" "nineteen"])
</code></p>

<p>Note: there is no “zero” as we don’t use it in spoken language.</p>

<p>Second group is numbers that divides 10:</p>

<p><code>clojure
(def decas ["" "ten" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"])
</code></p>

<p>Note: empty first element here is used to reduce additional check. Its length is 0, that has no effect at all.</p>

<p>And the last ones are three used values:</p>

<p><code>clojure
(def h "hundred")
(def t "thousand")
(def a "and")
</code></p>

<p>The basic function will calculate the length string representation of some number.
Let’s call it <code>word-length</code>.</p>

<p><code>clojure
(defn word-length [n]
  (cond (= n 1000) (+ (count t) (count (nth first20 1)))
        (&lt; n 100)
        (let [q (quot n 10) m (mod n 10)
              d (count (nth decas q))]
          (if (zero? m) d
              (if (&lt; q 2) (count (nth first20 (dec (+ m (* 10 q)))))
                  (+ d (count (nth first20 (dec m)))))))
        (&lt; n 1000)
        (let [q (quot n 100) m (mod n 100)]
          (if (zero? m) (+ (word-length q) (count h))
              (+ (count a) (count h) (word-length q) (word-length m))))))
</code></p>

<p>Little explanation:</p>

<ul>
  <li>If number is <code>1000</code> then the length of string “one” + “thousand”, 11.</li>
  <li>If number is lower than <code>100</code> then extract its decade part. If there is no
reminder for division by 10, the length is length of that decade part.</li>
  <li>Otherwise, if number in <code>first20</code>, length taken from array <code>first20</code>.</li>
  <li>Otherwise the length is decade part plus remainder.</li>
  <li>If number is lower than <code>1000</code> then extract hundred part. If there is no
reminder for division by 100, the length is “hundred” plus number of hundreds.</li>
  <li>Otherwise, the length is “hundred” plus number of hundreds, plus the word “and” and
recursively calculate the length of remainder, which is lower than <code>100</code>.</li>
</ul>

<p>Awful word-presentation of algorithm, because of… Reading code is much simpler, I know.</p>

<p>And the last part just sum up all word-lengths:</p>

<p><code>clojure
(reduce + (map word-length (range 1 1001)))
</code></p>

<p>Check the code <a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem017.clj">here</a>.</p>

<p>P.S. In fact algorithm is very simple, but needs some time to understand few branches.
By the way, the problem is little boring.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Golf: Game of Life]]></title>
    <link href="http://mishadoff.github.com/blog/code-golf-game-of-life/"/>
    <updated>2013-03-07T17:59:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/code-golf-game-of-life</id>
    <content type="html"><![CDATA[<p>Conway’s Game of Life in a tweet.</p>

<!-- more -->

<p>Recently, my friend pointed out me an article <a href="http://trelford.com/blog/post/140.aspx">Life in a tweet</a>
where <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a> was implemented in one tweet
(<em>less than 140 characters</em>) in Ruby and F#. I took this challenge.</p>

<h3 id="tweet">Tweet</h3>

<p>Here is the final version in <code>137</code> characters of Clojure:</p>

<p><code>clojure
(fn[g r](reduce(fn[i j](update-in i j(fn[v](get[v 1]
(-(apply +(map #(get-in g% 0)(for[a[-1 0 1]b[-1 0 1]]
(map + j[a b]))))v 2)0))))g r))
</code></p>

<h3 id="sugared-version">“Sugared” version</h3>

<p>Translate tweet to more readable code:</p>

<p><code>clojure
(defn step-sugar [grid range]
  (let [count-neighbours ;; determine number of neighbours
        (fn[[i j]]
          (reduce + (map #(get-in grid % 0)
                         (for[a [-1 0 1] b [-1 0 1]]
                           [(+ i a) (+ j b)]))))
        new-value  ;; calculate new value for cell
        (fn [v [i j]]
          (let [c (- (count-neighbours [i j]) v)]
            (cond (= 3 c) 1
                  (= 2 c) v
                  :else 0)))
        evolve-cell ;; update cell in a grid
        (fn[g i] (update-in g i #(new-value % i)))]
    (reduce evolve-cell grid range)))
</code></p>

<p>Actually, this version is cheating,
due to passing one extra-parameter <code>range</code> that contains all indices
need to be updated in form <code>[[0 1] [1 1]]...</code></p>

<p>On the other side it gives us two features:</p>

<ul>
  <li><strong>Works for rectangular grid</strong>. Although, initial
implementation assumes the world is square.</li>
  <li><strong>Specific part of world can be updated</strong>. It gives possibility
to update specific area in the world, for example <em>west organisms evolve faster</em>.</li>
</ul>

<p>To use this function you need:</p>

<ul>
  <li>World</li>
</ul>

<p><code>clojure
(def grid [[0 0 0]
           [1 1 1]
           [0 0 0]])
</code></p>

<ul>
  <li>Evolution</li>
</ul>

<p><code>clojure
(defn evolution [g]
  (let [p (count g) q (count (get g 0))
        range (for [i (range p) j (range q)][i j])]
    (iterate #(step-sugar % range) g)))
</code></p>

<ul>
  <li>Visualization</li>
</ul>

<p><code>clojure
(defn print-grid [g]
  (doseq [s (map #(apply str (replace {0 "." 1 "⚫"} %)) g)]
    (println s)))
</code></p>

<h3 id="testing">Testing</h3>

<p>To make sure results are correct use the following
<code>run</code> function and compare results to some common
<a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life#Examples_of_patterns">examples</a>.</p>

<p><code>clojure
(defn run [grid]
  (doseq [g (evolution grid)]
    (print-grid g)
    (Thread/sleep 1000)))
</code></p>

<p>Pattern examples:</p>

<p>``` clojure
(def block [[0 0 0 0]
            [0 1 1 0]
            [0 1 1 0]
            [0 0 0 0]])</p>

<p>(def glider [[0 0 1 0 0 0 0 0]
             [1 0 1 0 0 0 0 0]
             [0 1 1 0 0 0 0 0]
             [0 0 0 0 0 0 0 0]
             [0 0 0 0 0 0 0 0]
             [0 0 0 0 0 0 0 0]])
```</p>

<p>Full history of implementation and more life patterns
<a href="https://github.com/mishadoff/prog-experiment/blob/master/clojure/life.clj">available here</a></p>

<p>Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 016]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-016/"/>
    <updated>2013-03-05T01:31:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-016</id>
    <content type="html"><![CDATA[<blockquote>
  <p>2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.</p>

  <p>What is the sum of the digits of the number 2^1000 ?</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=16">http://projecteuler.net/problem=16</a></p>

<!-- more -->

<p>Are you kidding me?</p>

<ul>
  <li>Find 1000th <em>power of two</em></li>
  <li>Sum its digits</li>
</ul>

<p>In <a href="/blog/clojure-euler-problem-008/">Clojure Euler: Problem 008</a> we
learned how to sum digits in the number. Just gentle reminder:</p>

<p><code>clojure
(defn sum-of-digits [n]
  (reduce + (map #(- (int %) 48) (seq (str n)))))
</code></p>

<p>Now, let’s create sequence of powers of two:</p>

<p><code>clojure
(defn powers-of-2 []
  (iterate (partial * 2) 1))
</code></p>

<p>Unfortunately, this sequence throws <code>integer overflow</code> on the <code>64th</code> element.
We can fix that using <em>long arithmetics</em>, which known as <code>BigInteger</code> in Java.
Change <code>1</code> to <code>1N</code>.</p>

<p><code>clojure
(iterate (partial * 2) 1N)
</code></p>

<p>Another way is to use <strong>automatic promotion</strong> operator (<code>+'</code>, <code>*'</code>).
If result of some operation is not suitable for some type,
instead of invalid computation and runtime exception, clojure automatically promotes
the type to suitable one (<em>for example</em> <code>Long.MAX_VALUE +' 1</code> <em>works fine and produces
 correct result with type of</em> <code>BigInteger</code>):</p>

<p><code>clojure
(iterate (partial *' 2) 1)
</code></p>

<p>Choose <code>powers-of-2</code> that you prefer and final result will look like this:</p>

<p><code>clojure
(sum-of-digits (last (take 1001 (powers-of-2))))
</code></p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem016.clj">github</a></p>

<p><strong>P.S.</strong> Automatic promotion is a beatiful thing. But be aware about losing in
speed of calculations. Also, no way back. If promotion happened, <em>depromotion</em> won’t.</p>
]]></content>
  </entry>
  
</feed>
