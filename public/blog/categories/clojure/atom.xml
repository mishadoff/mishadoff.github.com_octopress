<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2012-11-06T20:53:43+02:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 004]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-004/"/>
    <updated>2012-10-31T19:30:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-004</id>
    <content type="html"><![CDATA[<blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.</p>

<p>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=4">http://projecteuler.net/problem=4</a></p>

<!-- more -->


<p><a href="http://en.wikipedia.org/wiki/Palindrome">Palindrome</a> is very interesting thing.
It's a sequence (of letters, numbers, words) that reads the same backwards. Examples: <em>MADAM</em>, <em>DID</em>, <em>2002</em>.
There are even some fun to compose palindrome sentences, like <code>He Goddam Mad Dog, eh?</code></p>

<p>Function to check if sequence is palindromic is very simple.
Compare first element with the last, second with the penultimate and so on.
It needs just <code>n/2</code> comparisons, so complexity of that algorithm is <code>O(n)</code>. Here is recursive solution:</p>

<p>``` clojure
(defn palindrome-recursive? [s]
  (if (empty? s) true</p>

<pre><code>(let [a (first s) b (last s)]
  (if (= a b) (recur (rest (butlast s))) false))))
</code></pre>

<p>```</p>

<p>Note two functions: function <a href="http://clojuredocs.org/clojure_core/clojure.core/last">last</a> - gets last element of collection,
<a href="http://clojuredocs.org/clojure_core/clojure.core/butlast">butlast</a> - drops last element of collection.
Both they work in linear time, so you might assume overall complexity is <code>O(n^2)</code>.
Using vectors we can get index access, and perform test much faster, but this detail is not important for now.</p>

<p>Using more cleaner way (obviously not the best) to implement this, which in particular I prefer, is the following:</p>

<p><code>clojure
(defn palindrome? [s]
  (= s (reverse s)))
</code></p>

<p>Function <a href="http://clojuredocs.org/clojure_core/clojure.core/reverse">reverse</a>, returns given sequence in reverse order in linear time.
Overall complexity is also <code>O(n)</code>.</p>

<p>To test whether number is palindrome or not, we just cast it to string, then cast string to sequence of chars, and using above function:</p>

<p><code>clojure
(defn palindrome-number? [n]
  (palindrome? (seq (str n))))
</code></p>

<p>Final solution is following:</p>

<p>``` clojure
(reduce max (filter palindrome-number?</p>

<pre><code>                  (for [i (range 100 1000) j (range i 1000)] (* i j))))
</code></pre>

<p>```</p>

<p>We just generate all combinations of 3-digit numbers multiplication, filter palindromes, and find maximum. Done.</p>

<p>This technique (<em>wow, is this technique?</em>) called <a href="http://en.wikipedia.org/wiki/Brute-force_search">brute-force</a>.
It's very consumable, because test each possible combination.
But it's common algorithm to such sort of problems.
There are lot of clever brute force optimization to reduce set of possible values, but it is still brute force.
As you see, in the code above, we also used small optimization.
We iterate first multiplicand <code>i</code> from <code>100</code> to <code>1000</code> to cover all 3-digits numbers, and <code>j</code> iterated not from <code>100</code> but from <code>i</code>.
This is because multiplication <code>375 * 468</code> gives the same result as <code>468 * 375</code>. Just because <a href="http://en.wikipedia.org/wiki/Commutative_property">commutative property</a>.
Roughly, this reduces number of iterations by factor of 2.
Obviously, there are other optimizations, but they are not so value and reduces readability
(<em>If first number ends with 5 and second is even, then result ends with 0, and we skip this because in palindromic value 0 should be at the beginning</em>).</p>

<p><strong>Congratulations!</strong> 4 problems solved. And we know "so much" about clojure.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem004.clj">GitHub</a>.</p>

<p><strong>P.S.</strong> We create two separate functions for palindromes: one test sequence for palindrome,
second test number for palindrome and reuse first implementation. Some can say it's not good,
because we write functionality that we not needed (function <code>palindrome?</code>).
Particularly, I agree. We could hide <code>palindrome?</code> implementation inside <code>palindrome-number?</code> or make it private.
But we haven't did this and have function <code>palindrome?</code> that we can reuse in other problems. Also it shows important concept,
how we can reuse existing implementations to get new functionality. And again: maybe there is (<em>I'm sure there is</em>) another solution
which is more clever than bruteforce. But this solution works only <code>0.2</code> sec. on my machine, so this is ok.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 004]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-004/"/>
    <updated>2012-10-31T19:30:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-004</id>
    <content type="html"><![CDATA[<blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.</p>

<p>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=4">http://projecteuler.net/problem=4</a></p>

<!-- more -->


<p><a href="http://en.wikipedia.org/wiki/Palindrome">Palindrome</a> is very interesting thing.
It's a sequence (of letters, numbers, words) that reads the same backwards. Examples: <em>MADAM</em>, <em>DID</em>, <em>2002</em>.
There are even some fun to compose palindrome sentences, like <code>He Goddam Mad Dog, eh?</code></p>

<p>Function to check if sequence is palindromic is very simple.
Compare first element with the last, second with the penultimate and so on.
It needs just <code>n/2</code> comparisons, so complexity of that algorithm is <code>O(n)</code>. Here is recursive solution:</p>

<p>``` clojure
(defn palindrome-recursive? [s]
  (if (empty? s) true</p>

<pre><code>(let [a (first s) b (last s)]
  (if (= a b) (recur (rest (butlast s))) false))))
</code></pre>

<p>```</p>

<p>Note two functions: function <a href="http://clojuredocs.org/clojure_core/clojure.core/last">last</a> - gets last element of collection,
<a href="http://clojuredocs.org/clojure_core/clojure.core/butlast">butlast</a> - drops last element of collection.
Both they work in linear time, so you might assume overall complexity is <code>O(n^2)</code>.
Using vectors we can get index access, and perform test much faster, but this detail is not important for now.</p>

<p>Using more cleaner way (obviously not the best) to implement this, which in particular I prefer, is the following:</p>

<p><code>clojure
(defn palindrome? [s]
  (= s (reverse s)))
</code></p>

<p>Function <a href="http://clojuredocs.org/clojure_core/clojure.core/reverse">reverse</a>, returns given sequence in reverse order in linear time.
Overall complexity is also <code>O(n)</code>.</p>

<p>To test whether number is palindrome or not, we just cast it to string, then cast string to sequence of chars, and using above function:</p>

<p><code>clojure
(defn palindrome-number? [n]
  (palindrome? (seq (str n))))
</code></p>

<p>Final solution is following:</p>

<p>``` clojure
(reduce max (filter palindrome-number?</p>

<pre><code>                  (for [i (range 100 1000) j (range i 1000)] (* i j))))
</code></pre>

<p>```</p>

<p>We just generate all combinations of 3-digit numbers multiplication, filter palindromes, and find maximum. Done.</p>

<p>This technique (<em>wow, is this technique?</em>) called <a href="http://en.wikipedia.org/wiki/Brute-force_search">brute-force</a>.
It's very consumable, because test each possible combination.
But it's common algorithm to such sort of problems.
There are lot of clever brute force optimization to reduce set of possible values, but it is still brute force.
As you see, in the code above, we also used small optimization.
We iterate first multiplicand <code>i</code> from <code>100</code> to <code>1000</code> to cover all 3-digits numbers, and <code>j</code> iterated not from <code>100</code> but from <code>i</code>.
This is because multiplication <code>375 * 468</code> gives the same result as <code>468 * 375</code>. Just because <a href="http://en.wikipedia.org/wiki/Commutative_property">commutative property</a>.
Roughly, this reduces number of iterations by factor of 2.
Obviously, there are other optimizations, but they are not so value and reduces readability
(<em>If first number ends with 5 and second is even, then result ends with 0, and we skip this because in palindromic value 0 should be at the beginning</em>).</p>

<p><strong>Congratulations!</strong> 4 problems solved. And we know "so much" about clojure.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem004.clj">GitHub</a>.</p>

<p><strong>P.S.</strong> We create two separate functions for palindromes: one test sequence for palindrome,
second test number for palindrome and reuse first implementation. Some can say it's not good,
because we write functionality that we not needed (function <code>palindrome?</code>).
Particularly, I agree. We could hide <code>palindrome?</code> implementation inside <code>palindrome-number?</code> or make it private.
But we haven't did this and have function <code>palindrome?</code> that we can reuse in other problems. Also it shows important concept,
how we can reuse existing implementations to get new functionality. And again: maybe there is (<em>I'm sure there is</em>) another solution
which is more clever than bruteforce. But this solution works only <code>0.2</code> sec. on my machine, so this is ok.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 003]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-003/"/>
    <updated>2012-10-30T19:12:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-003</id>
    <content type="html"><![CDATA[<blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p>

<p>What is the largest prime factor of the number 600851475143?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=3">http://projecteuler.net/problem=3</a></p>

<!-- more -->


<p>If you familiar with <a href="http://en.wikipedia.org/wiki/Prime_number">prime numbers</a>, you apparently know basic algorithms to find them,
if not, I advice to get familiar with it. There are lot of problems devoted to prime numbers on Project Euler. So, read 10 minutes about prime numbers, and go on.</p>

<p>In few words, prime number is a number starting from 2 that has no divisors except <em>1</em> and <em>itself</em>.
Exposing this logic on all numbers, we can simply find first prime numbers: <code>2, 3, 5, 7, 11, ...</code></p>

<p>To implement function that search for prime numbers we can implement predicate, that test whether number is prime or not:</p>

<p>``` clojure
(defn prime? [n]
   (= 2 (reduce +</p>

<pre><code>            (for [i (range 1 (inc n))]
              (if (= 0 (mod n i)) 1 0)))))
</code></pre>

<p>```</p>

<p>We iterate from 1 up to number and calculate reminder of division number by iteration counter.
If result is zero we return 1, otherwise we return 0.
For each number we get list with length of that number that marked with 1 for exact divisors.
For example for <code>6</code> list will be <code>(1 1 1 0 0 1)</code>, and for <code>7</code> list will be <code>(1 0 0 0 0 0 0 1)</code>.
Than we calculate sum of this list, which represents number of divisors. If count is two, that means number is prime.
This is simplest algorithm for testing prime number, built from prime number definition.</p>

<p>Performing small optimization you can see that in lists above, first and last elements are always equals to 1.
We can just drop them. Another optimization is we don't need go on when we found at least one remainder.
And I'm pretty sure you can find lot of flaws in this implementation.</p>

<p>But the most useful optimization is assumption that we don't need iterate to <code>n</code>, we can iterate to <code>sqrt(n)</code>.
This is based on fact that if we found some number <code>a</code> that is divisor of <code>n</code>, then there is another number <code>b = n / a</code>.
And <code>b</code> is also divisior of <code>n</code>. Little transformation gives us <code>a * b = n</code>. Assume <code>a &lt; b</code>, so if we found <code>a</code> we don't need to seek for <code>b</code>.
Number <code>n</code> is not prime. Maximum value of a achieved when <code>a</code> equals to <code>b</code>, <code>a^2 = n</code>, <code>a = sqrt(n)</code>.
This is reduce complexity of algorithm from <code>O(n)</code> to <code>O(sqrt(n))</code>.</p>

<p>In <a href="http://mishadoff.github.com/blog/clojure-euler-problem-002/">previous problem</a> we mentioned <code>clojure.contrib.lazy-seqs</code> package,
where we have primes lazy sequence. Let's use it!</p>

<p>Algorithm for solving our problem is following:</p>

<ol>
<li>Iterate through all prime number that less than square root of number</li>
<li>If this number is divisor add it to list</li>
<li>Find maximum from that list</li>
</ol>


<p>To transform statements above into clojure, we get:</p>

<p>``` clojure
(defn greatest-prime-of [number]
  (reduce max (filter #(zero? (mod number %))</p>

<pre><code>                  (take-while #(&lt; % (sqrt number)) primes))))
</code></pre>

<p>```</p>

<p>Something new here:</p>

<ul>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/max">max</a> - function that returns the greatest number of its arguments.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/zero_q">zero?</a> - predicate that test whether number is equal to zero or not.
The same as <code>#(= 0 %)</code>.</li>
<li><a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/sqrt">sqrt</a> - function from <code>clojure.contrib.math</code>. Name is obvious.</li>
</ul>


<p>Now, we want to find result. Run the line</p>

<p><code>clojure
(greatest-prime-of 600851475143))
</code></p>

<p><strong>Congratulations!</strong> Third problem solved.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem003.clj">GitHub</a> for lazy!</p>

<p><strong>P.S.</strong> Instead of using <code>clojure.contrib.math</code> for square root we could just write <code>(Math/sqrt n)</code> and got rid of dependency.
But for me is better to reuse something that was implemented in library. It's tested and worked, where your implementation can miss some point.
If you have time, dig more into <code>clojure.contrib.math</code>. It needs about 8 minutes. There are only 8 functions,
but you will probably reinvent them all the time:
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/expt">expt</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/abs">abs</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/sqrt">sqrt</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/round">round</a> and others.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 002]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-002/"/>
    <updated>2012-10-15T18:46:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-002</id>
    <content type="html"><![CDATA[<blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>

<p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>

<p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=2">http://projecteuler.net/problem=2</a></p>

<!-- more -->


<p>This is not hard problem with objective to make you familliar with <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonacci numbers</a>
(this numbers will appear in a lot of next problems). It can be implemented with the straightforward manner with the following rules applied:</p>

<ul>
<li><code>F(0) = 1</code></li>
<li><code>F(1) = 1</code></li>
<li><code>F(n) = F(n-1) + F(n-2)</code></li>
</ul>


<p>So, we can define simple recursive function to calculate n-th number of Fibonacci sequence in clojure:</p>

<p>``` clojure
(defn fib [n]
  (if (or (= n 1) (= n 0)) 1</p>

<pre><code>(+ (fib (- n 1)) (fib (- n 2)))))
</code></pre>

<p>```</p>

<p>It's probably not the best implementation of Fibonacci numbers, but it shows the idea.
We can check that it works correctly by calling <code>(map fib (range 10))</code> that produces sequence <code>(1 1 2 3 5 8 13 21 34 55)</code>.
Problem appears when we try to calculate <code>40th</code> number. Calling that function on my machine takes ~20 seconds. Not good.</p>

<p>The reason of such bad performance is repeated calculations. Let's see how expanded call <code>(fib 40)</code>.
It produces <code>(+ (fib 39) (fib 38))</code>, where <code>(fib 39)</code> expanded to <code>(+ (fib 38) (fib 37))</code> and <code>(fib 38)</code> to <code>(+ (fib 37) (fib 36))</code> etc.
The growth with factor of 2. And with these two expansions we calculated 2 values that we calculated before, <code>37th</code> and <code>38th</code>.</p>

<p>We can make better if we producing our sequence in direct order, instead of reverse. This way function will be more complex than previous:</p>

<p>``` clojure
(defn fib-seq [n]
  ((fn [a b c seq]</p>

<pre><code>(cond (= 1 n) [1]
      (= c n) seq
      :else (recur b (+ a b) (inc c) (conj seq (+ a b)))))
</code></pre>

<p>   1 1 2 [1 1]))
```</p>

<p>Let's see what's new clojure features we used:</p>

<ol>
<li>We define function inside function. Why we did this? All is because we used "helper"-function for accumulate current Fibonacci sequence.
It used only in function <code>fib-seq</code>, so we don't need to define it at the root level. It closed for using for everyone, except <code>fib-seq</code>.</li>
<li>Next thing we define anonymous function by keyword <code>fn</code>. Basically it's the right thing to define functions. <code>defn</code> just shortcut for <code>(def (fn [] ))</code>, and..</li>
<li>..we pass default (initialization) values for helper function <code>1 1 2 [1 1]</code>.</li>
<li>I skip logic of helper function here. It is pretty straightforward, just notice two new clojure functions that we used.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/cond">cond</a> - similar to switch-case structure in C-style languages.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/conj">conj</a> - add value to collection. Dependant on collection type,
insert new value in different places. For our case we using vector, so we add this value to the end of vector.</li>
</ol>


<p>Now we can call <code>(fib-seq 40)</code> and it calculates all 40 values very quickly. Nice.</p>

<p>But let's return to problem description <em>"... whose values do not exceed 4 million..."</em>.
How do we know how many values we need to take that do not exceed 4 million? 50? 100? 112?
This is drawback of our <code>fib-seq</code> function and we need to rewrite it...or take a look at clojure mechanism called lazy sequences.</p>

<h3>Lazy sequences</h3>

<p>In few words, lazy sequence is infinite sequence of some values, that calculates due to some expression.
The main idea here is the word <em>lazy</em> that means we evaluate expressions when they are needed.
For example, sequence of natural numbers is a lazy sequence. Clojure supports lazy sequences along with operations on them.
So, we can combine sequences, limit, filter etc. Java do not support lazy sequences but similar functionality can be implemented with generators concept.
Generator interface provides method <code>next()</code> to retrieve next value in the sequence, and that method evaluates value.
But this approach is very poor with comparison to clojure lazy sequences.</p>

<p>Lazy sequences in clojure can be treated like ordinary sequences. Obviously some methods make no sense, due to infinity of sequence (<code>count</code>, <code>last</code>, etc.)
There are way to define lazy sequences by using macro <code>lazy-seq</code>. But most common way to do it with the function iterate.
It takes function <code>f</code>, and initial value <code>a</code>, and produces lazy sequence <code>(a, f(a), f(f(a)),...)</code>.
For example lazy sequence of natural numbers we can define as following: <code>(iterate inc 1)</code>. Then we can play with this sequence as we want.</p>

<p><strong>WARNING:</strong> <em>Never call lazy sequence without limiting functions. It tries to evaluate all, and... You know, never call.</em></p>

<p>Now, we have a little understanding what lazy sequence is, and can implement Fibonacci lazy sequence.</p>

<p><code>clojure
(defn fib-seq-lazy []
  (map first (iterate (fn [[a b]] [b (+ a b)]) [1 1])))
</code></p>

<p>Ok, What's here:</p>

<ol>
<li>Read from the end. We apply anonymous function to vector <code>[1 1]</code> and produce lazy sequence with <code>iterate</code>.</li>
<li>Note double square brackets in anonymous function definition. Outer brackets indicate function variables.
Inner brackets indicate that we take one parameter to function as argument.
This parameter is a sequence and we map to <code>a</code> and <code>b</code>, first and second elements in that sequence.
For example for first call, <code>a</code> bound to <code>1</code>, <code>b</code> bound to <code>1</code>.</li>
<li>Our iterate produces lazy sequence with following format <code>([1 1] [1 2] [2 3] [3 5] [5 8] ...)</code>.
Our Fibonacci sequence is just first value of each pair, and we using...</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/map">map</a> - takes function and applies it to each element of collection.
This function also produces lazy sequence.</li>
<li>To gather all in one we get lazy sequence that represent Fibonacci numbers <code>(1 1 2 3 5 8 ...)</code>.</li>
</ol>


<p>Now we have to implement functionality that in problem description. Immediately, code:</p>

<p><code>clojure
(reduce +
  (filter even? (take-while #(&lt; % 4000000) (fib-seq-lazy))))
</code></p>

<p>Another one(<em>two</em>)-liner. Good.</p>

<ol>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/take-while">take-while</a> - takes values from sequence (includes lazy sequences) while condition is true.</li>
<li><code>#(&lt; % 4000000)</code> - <code>#()</code> it's <a href="http://en.wikipedia.org/wiki/Tautology_%28rhetoric%29">shorter shortcut</a> for anonymous function.
In our case predicate return true if value lower than 4 millions. Exacly what we need.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/filter">filter</a> - return all values for which predicate return true.
Instead of take-while it proceed all sequence till the end, and, obviously, do not accept lazy sequences.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/even_q">even?</a> - predicate that return true, if number is even.
Note: this is common way to append function name with question mark to indicate that this function is predicate (return true or false). Just convention.</li>
<li>And, finally, sum all of them.</li>
</ol>


<p><strong>Congratulations!</strong> We just solved Project Euler Problem 2.</p>

<p>There are also few optimisations to get result faster, but <a href="http://en.wikipedia.org/wiki/KISS_principle">KISS</a>.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem002.clj">GitHub</a> for lazy!</p>

<p><strong>P.S.</strong> We could use <code>clojure-contrib</code> library, which is often deployed with standard <code>clojure-core</code>.
<code>clojure-contrib.lazy-seqs</code> library contains method <code>(fibs)</code> that also produces lazy Fibonacci sequence.
And interestingly it implemented the same way as we did.
There are two more lazy sequences: prime numbers and powers of 2.
It's good practice to use existing functionality and not invent vehicle.</p>

<p>Have fun!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure + Emacs + Leiningen + nREPL]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-plus-emacs-plus-leiningen-plus-nrepl/"/>
    <updated>2012-10-13T18:19:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-plus-emacs-plus-leiningen-plus-nrepl</id>
    <content type="html"><![CDATA[<p>This article provides step-by-step instruction how to configure Clojure environment.</p>

<!-- more -->


<h3>Little history</h3>

<p>Long time I was using <a href="https://github.com/technomancy/swank-clojure">swank-clojure</a> as connector to my Clojure projects from Emacs <a href="http://common-lisp.net/project/slime/">SLIME</a>.
But, suddenly, I lost all my emacs preferences and needed to configure it again (<em>yeah, it's my fault, this time I've created configuration on GitHub</em>).
So, when I entered to swank-clojure project page, I was a bit frustrated by the following message:
<em>"This project is no longer under active development. New users are strongly encouraged to try out</em> <a href="https://github.com/kingtim/nrepl.el">nrepl.el</a> <em>instead"</em>.
Ok, let's see what nrepl is.</p>

<h3>Why emacs?</h3>

<p>I don't know. I like lisp, and emacs created in (e)lisp.
Strange hotkeys like <code>C-x C-s</code>. Huge functionality, that you can configure all days. Internal package manager. Plenty of modes.
Mail client. Games. Whatever. Oh wait, I forgot text editor. I really, can't find any great reason that convince somebody to use emacs as IDE. But I like it.</p>

<p>There is a good <a href="http://xkcd.com/378/">xkcd</a> comics about emacs.</p>

<p>By the way, there are lot of IDEs that can be configured much simpler way than described in this article:</p>

<ul>
<li><a href="http://clojure.bighugh.com/">Clojure Box</a> - emacs install, preconfigured for clojure. Only for Windows</li>
<li><a href="http://code.google.com/p/counterclockwise/">Counter Clockwise</a> - eclipse plugin</li>
<li><a href="http://www.enclojure.org/">Enclojure</a> - netbeans plugin</li>
<li><a href="http://plugins.intellij.net/plugin/?id=4050">La Clojure</a> - IDEA plugin</li>
<li><a href="http://www.vim.org/scripts/script.php?script_id=2501">VimClojure</a> - vim plugin</li>
<li><a href="http://www.chris-granger.com/2012/04/12/light-table---a-new-ide-concept/">Light Table</a> - new generation of IDEs?</li>
</ul>


<p>So, before reading, ask yourself, Do I really need emacs?</p>

<h3>Emacs</h3>

<p>First of all you need to install emacs, to get your future clojure coding environment. I'm using ubuntu, so I just type:</p>

<p><code>sudo apt-get install emacs</code></p>

<p>and it install emacs 23. If you using another OS, or do not trust package manager,
check <a href="http://www.gnu.org/software/emacs/">GNU Emacs official website</a> for installation instructions.</p>

<p>Also, you need to install emacs package-manager.</p>

<ol>
<li>Copy file <a href="http://repo.or.cz/w/emacs.git/blob_plain/1a0a666f941c99882093d7bd08ced15033bc3f0c:/lisp/emacs-lisp/package.el">package.el</a>
to your <code>~/emacs.d/</code> folder.</li>
<li>In your <code>~/.emacs</code> file add folowing lines:</li>
</ol>


<p>```
(add-to-list 'load-path "~/.emacs.d/")
(load "package")
(require 'package)
(add-to-list 'package-archives</p>

<pre><code>'("marmalade" .
  "http://marmalade-repo.org/packages/"))
</code></pre>

<p>(package-initialize)
```</p>

<p>These lines will be loaded after emacs restarted and install package manager.
To check if it works, type <code>M-x package-list-packages</code> and this show you list of emacs plugins, hope you will find something useful there.</p>

<h3>Leiningen</h3>

<p><a href="http://leiningen.org/">Leiningen</a> is a build tool for clojure. It also controls dependency management, automation, tests, etc.
Pretty like <a href="http://maven.apache.org/">maven</a> for Java.</p>

<p>To install lein 2 (it's shorter name for Leiningen) do the following:</p>

<ol>
<li>Download <a href="https://raw.github.com/technomancy/leiningen/preview/bin/lein">lein script</a></li>
<li>Place it on your <code>$PATH</code></li>
<li>Make it executable</li>
</ol>


<p>On ubuntu this can be performed with the following commands:</p>

<pre><code>cd ~/
mkdir bin
</code></pre>

<p>Add line export <code>PATH=~/bin:$PATH</code> to your <code>~/.bashrc</code> file</p>

<pre><code>cd ~/bin
wget https://raw.github.com/technomancy/leiningen/preview/bin/lein
chmod +x lein
</code></pre>

<p>Execute lein, for first time it will download default lein package. To verify installation run <code>lein version</code>.
On my machine for the post date it prints: <code>Leiningen 2.0.0-preview10 on Java 1.6.0_24 OpenJDK 64-Bit Server VM</code></p>

<h3>nREPL</h3>

<p>We have already installed emacs package manager, so we can get nrepl from there.
It also needs emacs major mode <code>clojure-mode</code>, so type the following commands in emacs to install needed packages:</p>

<pre><code>M-x package-install clojure-mode
M-x package-install nrepl
</code></pre>

<p>Try <code>M-x nrepl-jack-in</code> to execute REPL, where you can play with clojure commands.</p>

<h3>Bind all together</h3>

<p>We have fully configured environment for clojure and how to use it?</p>

<p>Create new clojure project using lein:</p>

<p><code>lein new helloworld</code></p>

<p>Start nREPL server in emacs:</p>

<p><code>M-x nrepl-jack-in</code></p>

<p>Open core project file in emacs:</p>

<p><code>C-f helloworld/src/helloworld/core.clj</code></p>

<p>Write simple function:</p>

<p><code>clojure
(ns helloworld.core)
(defn hello []
  (println "Hell, O'World!"))
</code></p>

<p>Compile it:</p>

<p><code>C-c C-k</code></p>

<p>Switch to nREPL buffer, change namespace and run hello function:</p>

<p><code>clojure
(ns helloworld.core)
(hello)
</code></p>

<p>Probably, you'll get output:</p>

<pre><code>Hell, O'World!
nil
</code></pre>

<p><strong>Congratulations!</strong> You just created working clojure project.</p>

<p><strong>Note:</strong> this configuration covers only basic clojure+emacs environment.
There are plenty plugins to work with parenthesis, documentation, tests, auto-completion and lot more.
I'll do my best to cover such plugins in the next sections. Also, emacs23 is an old version of emacs, verison 24
is currently available.</p>
]]></content>
  </entry>
  
</feed>
