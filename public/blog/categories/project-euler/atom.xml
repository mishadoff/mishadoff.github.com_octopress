<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: project-euler | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/project-euler/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2012-11-28T00:26:43+02:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 008]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-008/"/>
    <updated>2012-11-27T22:53:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-008</id>
    <content type="html"><![CDATA[<blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=8">http://projecteuler.net/problem=8</a></p>

<p><em>Large number under the cut.</em></p>

<!-- more -->


<p><code>
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
</code></p>

<p>Idea behind this problem is pretty straightforward:</p>

<ol>
<li>Init <code>maximum</code> with some small value, zero would be good.</li>
<li>Take first 5 digits, calculate the product.</li>
<li>If product is greater than our current <code>maximum</code>, reassign it.</li>
<li>Shift, to take other 5 digits, and back to the step 1.</li>
</ol>


<p>A simple optimization can be applied: if our last element of 5 digit group is zero,
then skip 5 shifts. But it's details.</p>

<p>Let's make our problem little harder to get more from clojure.</p>

<p>Assume that these digits stored in the file. First thing we need: to read the file.</p>

<p><code>clojure
(slurp "path/to/the/file")
</code></p>

<p><a href="http://clojuredocs.org/clojure_core/clojure.core/slurp">slurp</a> is the simplest
function to read file content (<em>In fact, not only files</em>).
It just returns string representation of the whole file.</p>

<p>Then we need to break one large string into symbols.</p>

<p><code>clojure
(seq "helloyo") =&gt; (\h \e \l \l \o \y \o)
</code></p>

<p><a href="http://clojuredocs.org/clojure_core/clojure.core/seq">seq</a> return a sequence with linear access
to collection. If applied to string, return sequence of characters.</p>

<p>But, there are some garbage in the file we don't want, new lines for example.</p>

<p><code>clojure
(remove #(= \newline %) [\h \e \l \l \o \newline \y \o])
</code></p>

<p>(<em>slash</em>) + something - represents character in clojure.
<code>\newline</code> is a new line, known as <code>\n</code> in other languages.</p>

<p>Now we have long sequence with all digits from file.
Need to get all consecutive groups with 5 letters.</p>

<p><code>clojure
(partition 5 1 [\h \e \l \l \o \y \o]) =&gt; [[\h \e \l \l \o] [\e \l \l \o \y] ... ]
</code></p>

<p><a href="http://clojuredocs.org/clojure_core/clojure.core/partition">partition</a>
is an excelent function for such tasks. We specify <code>5</code> - size of partition,
and <code>1</code> shift size. It generates all consecutive groups with 5 elements till the end.</p>

<p>Calulating the product for each group gives us the solution.</p>

<p><code>clojure
(reduce * [1 2 3 4])
</code></p>

<p>Not so fast.</p>

<p>You, probably, get <code>ClassCastException</code>.</p>

<p>After reading the file, we just get bunch of characters,
instead of digits in mathematical sense. And applied mathematical operation <code>*</code> to them.
So, simply speaking, <code>\1</code> is not <code>1</code>.</p>

<p>That's why we need to transform every digit character to it's actual digit value.</p>

<p><code>clojure
(map #(- (int %) 48) [\1 \2 \3]) =&gt; [1 2 3]
</code></p>

<p>This awful implementation do the work.</p>

<ul>
<li>Cast each character to int, get the <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>
representation for digit.</li>
<li>From each ASCII value we subtract <code>48</code> and get digit value.</li>
</ul>


<p>Applying <code>product</code> of digits defined earlier we get solution to this problem.</p>

<p>Again, full code on <a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem008.clj">GitHub</a>.</p>

<p><strong>P.S.</strong> <code>slurp</code> function very powerful and has may applications. You can specify encoding
for reading as you want or read whole html page by url. But it is also very dangerous function,
because reads all file contents to the memory and can take considerable amount of time. If you have
a large file, say 15GB, read it line by line with buffered reader. Also, note
<a href="http://clojuredocs.org/clojure_core/clojure.core/spit">spit</a> function. It is opposite to <code>slurp</code> -
writes string to the file.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 007]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-007/"/>
    <updated>2012-11-20T15:37:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-007</id>
    <content type="html"><![CDATA[<blockquote><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>

<p>What is the 10001st prime number?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=7">http://projecteuler.net/problem=7</a></p>

<!-- more -->


<p>It's also pretty clear problem to make you more familiar with prime numbers.
As I said in <a href="/blog/clojure-euler-problem-003">Clojure Euler: Problem 003</a>,
big amount of Project Euler problems devoted to prime numbers so it is <strong>MUST HAVE</strong> (<em>I don't like this phrase either</em>)</p>

<p>You need to implement by yourself effective prime number algorithm. And only after that use one from library.
As we do.</p>

<p><code>clojure
(:use [clojure.contrib.lazy-seqs :only (primes)])
</code></p>

<p>This line import just one symbol <code>primes</code> to your namespace. It's a prime numbers lazy sequence. Lazy sequences briefly covered
in <a href="/blog/clojure-euler-problem-002">Clojure Euler: Problem 002</a> or <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">Wikipedia article</a>,
that's enough for now.</p>

<p>Return to question.</p>

<blockquote><p>What is the 10001st prime number?</p></blockquote>

<p>No problem.</p>

<p><code>clojure
(last (take 10001 primes))
</code></p>

<p>Two lines of code: one for import, one for solution. What can be simpler?</p>

<p>Note, that <a href="http://clojuredocs.org/clojure_core/clojure.core/last">last</a> return last element of the sequence and works in linear time.</p>

<p>Another one problem solved in few <strike>seconds</strike> minutes.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem007.clj">GitHub</a></p>

<p><strong>P.S.</strong> Actually, I lied. In linked solution I use 6 lines of code: namespace declaration, use, <em>empty line</em>,
comment with executing time, function declaration and, finally, solution.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 006]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-006/"/>
    <updated>2012-11-17T14:05:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-006</id>
    <content type="html"><![CDATA[<blockquote><p>The sum of the squares of the first ten natural numbers is,</p>

<p>1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385</p>

<p>The square of the sum of the first ten natural numbers is,</p>

<p>(1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p>

<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 âˆ’ 385 = 2640.</p>

<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=6">http://projecteuler.net/problem=6</a></p>

<!-- more -->


<p>This problem is very simple, even simpler than previous one, that confirms fact that all Project Euler problems
are <strong>NOT</strong> in increasing complexity order. Ok, let's split our problem into two subproblems.</p>

<h3>Sum of the squares</h3>

<p>First, we need a square function:</p>

<p><code>clojure
(defn sqr [n] (* n n))
</code></p>

<p>Then, sum of squares of the first one hundred natural numbers we calculate with common <code>(reduce + list)</code> idiom:</p>

<p><code>clojure
(reduce + (map sqr (range 1 101)))
</code></p>

<h3>Square of the sum</h3>

<p>Just take a sum, and square it:</p>

<p><code>clojure
(sqr (reduce + (range 1 101)))
</code></p>

<h3>Bind all together</h3>

<p>We splitted our problem into two smaller, now is time to bind all. We can just subtract results obtained
but you see, that both of smaller solutions uses common piece of code <code>(range 1 101)</code>. Move it to <code>let</code> form.</p>

<p><code>clojure
(let [rn (range 1 101)]
  (- (sqr (reduce + rn)) (reduce + (map sqr rn)))))
</code></p>

<p>That' all. I've got result in less than millisecond.
Maybe there are some pitfalls in this problem (<em>e.g. integer overflow for larger ranges</em>)
but this most straightforward solution works fine.</p>

<p>Congratulations!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem006.clj">GitHub</a></p>

<p><strong>P.S.</strong> First time I solved this problem and was confused: <em>Where is the trick?</em> Seems nowhere.
That's why using most straightforward solution is often the best choice (<em>excluding obvious cases, of course</em>).
It has fast implementation, and if it fails, it fails fast.</p>

<p><strong>Fail Fast, Succeed Faster</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 005]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-005/"/>
    <updated>2012-11-09T19:01:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-005</id>
    <content type="html"><![CDATA[<blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>

<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=5">http://projecteuler.net/problem=5</a></p>

<!-- more -->


<p>It's a tricky problem. First look gives us straightforward solution:
Take a number, test if it evenly divisible by all of needed numbers, if yes - we good,
otherwise increment number and test again, and again, and again...</p>

<p>No, really, assume it's our function to test divisibility by all 20 numbers:</p>

<p>``` clojure
(defn evenly-divisible-by-20? [n]
  (zero? (reduce +</p>

<pre><code>(for [i (range 2 21)]
  (mod n i)))))
</code></pre>

<p>```</p>

<p>Awful implementation, but keeps the idea.
If sum of all remainders equals to zero, then every remainder equals to zero.
Now, using this function we write naive implementation:</p>

<p>``` clojure</p>

<pre><code>(first
  (drop-while #(not (evenly-divisible-by-20? %)) (iterate inc 1)))
</code></pre>

<p>```</p>

<p>Note, function <a href="http://clojuredocs.org/clojure_core/clojure.core/drop-while">drop-while</a>
similar to take-while, but skips values until they meet predicate condition.</p>

<p>Waiting for result? Take a cup of tea and wait a little. Still waiting? Wait a little more...</p>

<p>I did not post exact answer here, but result greater than 100 millions.
And obviously this linear algorithm will work considerable amount of time.
So, stop the execution and let's see at the problem from the other end.</p>

<p><em>What is the smallest number that evenly divisible by 1 and 2?</em>
Obviously 2.</p>

<p><em>What is the smallest number that evenly divisible by 2 and 3?</em>
A bit harder, but answer is 6.</p>

<p><em>What is the smallest number that evenly divisible by 4 and 5?</em>
20.</p>

<blockquote><p>Oh, it's just multiplication</p></blockquote>

<p>Unfortunately, no. Take numbers <code>4</code> and <code>6</code>, multiplication gives us <code>24</code> and it will be evenly divisible by <code>4</code> and <code>6</code>, but
this number is not the <em>smallest</em>. Snmallest number for this case will be <code>12</code>.</p>

<p>There is a function, that finds smallest number divisible by 2 different numbers.
This function called <a href="http://en.wikipedia.org/wiki/Least_common_multiple">Least Common Multiple</a> (<em>lcm</em>).
There are lot of different methods to calculate it, but we will use one that uses
<a href="http://en.wikipedia.org/wiki/Greatest_common_divisor">Greatest Common Divisor</a> (<em>gcd</em>)</p>

<p><img src="http://upload.wikimedia.org/math/5/b/3/5b3f3c62dd59cc5594af7b2ece3798fb.png" alt="" /></p>

<p>Where <em>gcd</em> calculated according to <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid's algorithm</a></p>

<p>``` clojure
(defn gcd [n k]
  (loop [a n b k]</p>

<pre><code>(if (zero? b) a (recur b (mod a b)))))
</code></pre>

<p>```</p>

<p>Using formula above, our <em>lcm</em> function will look like this:</p>

<p><code>clojure
(defn lcm [n k]
  (/ (abs (* n k)) (gcd n k)))
</code></p>

<p>You see, here we need <code>abs</code> function. Nothing hard to implement it, but if we remember
<a href="/blog/clojure-euler-problem-004">previous problem</a> there are was a reference
to <code>clojure.contrib.math</code> library. <code>abs</code> there and we can use it, just add to your namespace definition</p>

<p><code>clojure
(:use [clojure.contrib.math])
</code></p>

<p>Oh look, even <code>lcm</code> and <code>gcd</code> functions there. Excellent.</p>

<p>Now we can solve the problem. Remember the <code>reduce</code> function?</p>

<p><code>clojure
(reduce lcm (range 1 21))
</code></p>

<p>Actually, this one-liner is solution. And it gives us correct result.</p>

<p>What happens here? We iteratively (<em>with using reduce</em>) find the lcm for <code>1</code> and <code>2</code>,
then for result and <code>3</code>, for result and <code>4</code> and so on.</p>

<p><strong>Great!</strong> One more problem solved!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem005.clj">GitHub</a></p>

<p><strong>P.S.</strong> One lesson we learned here. Be aware about library functionality. It helps you
to solve problems and avoid coward mistakes. For example, we have incorrect above implementation
for <code>lcm</code> function. If we call <code>(lcm 0 0)</code> program fails with <code>DivideByZero</code> exception.
It still solve our problem, but in future uses can be an additional problem.
But in lib implementation this error is covered. And we can be sure that <em>almost always</em> libs contain much less
errors that your <em>new fancy wheel</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 003]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-003/"/>
    <updated>2012-10-30T19:12:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-003</id>
    <content type="html"><![CDATA[<blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p>

<p>What is the largest prime factor of the number 600851475143?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=3">http://projecteuler.net/problem=3</a></p>

<!-- more -->


<p>If you familiar with <a href="http://en.wikipedia.org/wiki/Prime_number">prime numbers</a>, you apparently know basic algorithms to find them,
if not, I advice to get familiar with it. There are lot of problems devoted to prime numbers on Project Euler. So, read 10 minutes about prime numbers, and go on.</p>

<p>In few words, prime number is a number starting from 2 that has no divisors except <em>1</em> and <em>itself</em>.
Exposing this logic on all numbers, we can simply find first prime numbers: <code>2, 3, 5, 7, 11, ...</code></p>

<p>To implement function that search for prime numbers we can implement predicate, that test whether number is prime or not:</p>

<p>``` clojure
(defn prime? [n]
   (= 2 (reduce +</p>

<pre><code>            (for [i (range 1 (inc n))]
              (if (= 0 (mod n i)) 1 0)))))
</code></pre>

<p>```</p>

<p>We iterate from 1 up to number and calculate reminder of division number by iteration counter.
If result is zero we return 1, otherwise we return 0.
For each number we get list with length of that number that marked with 1 for exact divisors.
For example for <code>6</code> list will be <code>(1 1 1 0 0 1)</code>, and for <code>7</code> list will be <code>(1 0 0 0 0 0 0 1)</code>.
Than we calculate sum of this list, which represents number of divisors. If count is two, that means number is prime.
This is simplest algorithm for testing prime number, built from prime number definition.</p>

<p>Performing small optimization you can see that in lists above, first and last elements are always equals to 1.
We can just drop them. Another optimization is we don't need go on when we found at least one remainder.
And I'm pretty sure you can find lot of flaws in this implementation.</p>

<p>But the most useful optimization is assumption that we don't need iterate to <code>n</code>, we can iterate to <code>sqrt(n)</code>.
This is based on fact that if we found some number <code>a</code> that is divisor of <code>n</code>, then there is another number <code>b = n / a</code>.
And <code>b</code> is also divisior of <code>n</code>. Little transformation gives us <code>a * b = n</code>. Assume <code>a &lt; b</code>, so if we found <code>a</code> we don't need to seek for <code>b</code>.
Number <code>n</code> is not prime. Maximum value of a achieved when <code>a</code> equals to <code>b</code>, <code>a^2 = n</code>, <code>a = sqrt(n)</code>.
This is reduce complexity of algorithm from <code>O(n)</code> to <code>O(sqrt(n))</code>.</p>

<p>In <a href="http://mishadoff.github.com/blog/clojure-euler-problem-002/">previous problem</a> we mentioned <code>clojure.contrib.lazy-seqs</code> package,
where we have primes lazy sequence. Let's use it!</p>

<p>Algorithm for solving our problem is following:</p>

<ol>
<li>Iterate through all prime number that less than square root of number</li>
<li>If this number is divisor add it to list</li>
<li>Find maximum from that list</li>
</ol>


<p>To transform statements above into clojure, we get:</p>

<p>``` clojure
(defn greatest-prime-of [number]
  (reduce max (filter #(zero? (mod number %))</p>

<pre><code>                  (take-while #(&lt; % (sqrt number)) primes))))
</code></pre>

<p>```</p>

<p>Something new here:</p>

<ul>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/max">max</a> - function that returns the greatest number of its arguments.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/zero_q">zero?</a> - predicate that test whether number is equal to zero or not.
The same as <code>#(= 0 %)</code>.</li>
<li><a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/sqrt">sqrt</a> - function from <code>clojure.contrib.math</code>. Name is obvious.</li>
</ul>


<p>Now, we want to find result. Run the line</p>

<p><code>clojure
(greatest-prime-of 600851475143))
</code></p>

<p><strong>Congratulations!</strong> Third problem solved.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem003.clj">GitHub</a> for lazy!</p>

<p><strong>P.S.</strong> Instead of using <code>clojure.contrib.math</code> for square root we could just write <code>(Math/sqrt n)</code> and got rid of dependency.
But for me is better to reuse something that was implemented in library. It's tested and worked, where your implementation can miss some point.
If you have time, dig more into <code>clojure.contrib.math</code>. It needs about 9 minutes. There are only 9 functions,
but you will probably reinvent them all the time:
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/expt">expt</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/abs">abs</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/sqrt">sqrt</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/round">round</a> and others.</p>
]]></content>
  </entry>
  
</feed>
