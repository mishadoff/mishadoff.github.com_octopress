<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: project-euler | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/project-euler/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2013-07-06T16:00:21+03:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 018]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-018/"/>
    <updated>2013-05-17T00:26:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-018</id>
    <content type="html"><![CDATA[<blockquote>
  <p>By starting at the top of the triangle below and moving to adjacent numbers on the row below, the maximum total from top to bottom is 23.</p>
</blockquote>

<p><code>
       3
      7 4
     2 4 6
    8 5 9 3
</code></p>

<blockquote>
  <p>That is, 3 + 7 + 4 + 9 = 23.</p>

  <p>Find the maximum total from top to bottom of the triangle below:</p>

  <p>[Check out big triangle in original link]</p>

  <p>NOTE: As there are only 16384 routes, it is possible to solve this problem by trying every route.
However, Problem 67, is the same challenge with a triangle containing one-hundred rows;
it cannot be solved by brute force, and requires a clever method! ;o)</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=18">http://projecteuler.net/problem=18</a></p>

<!-- more -->

<p>As note says we can try every route and it will be just good.
Instead of that, we can behave much better with clever method.</p>

<p>(Some time ago, I gave basic explanation on my approach in <a href="http://stackoverflow.com/questions/8002252/euler-project-18-approach">StackOverflow question</a>)</p>

<p>We have example triangle:</p>

<p><code>
       3
      7 4
     2 4 6
    8 5 9 3
</code></p>

<p>Instead of testing each route from top to the bottom, we moving from bottom
to the top and always select the best choice. As we want to find the max sum, we perform addition im place.</p>

<p>Assuming we on the 3rd line (2 4 6).</p>

<p><strong>From 2</strong> we can go either 8 or 5, 8 is better (maximize your sum), then you calculate first
sum <code>8 + 2 = 10</code>.</p>

<p><strong>From 4</strong> we can go either 5 or 9, 9 is better, <code>4 + 9 = 13</code>.</p>

<p><strong>From 6</strong> we can go either 9 or 3, 9 is better, <code>9 + 6 = 15</code>.</p>

<p>Now, we removing last row, because we processed all routes and selected best ones, and replacing
3rd row with calculated sums. Current triangle looks like:</p>

<p><code>
        3
      7  4
    10 13 15
</code></p>

<p>Repeat the same action until we get one number, which will be solution.</p>

<p>Let’s transform this idea to clojure.</p>

<p>First of all we need datastructure to represent triangle.
List of lists would be good:</p>

<p><code>clojure
(def triangle '((3) (7 4) (2 4 6) (8 5 9 3)))
</code></p>

<p>Now we want to know, what direction generates the best sum.</p>

<p><code>clojure
(defn max-row [lst]
  (map #(reduce max %) (partition 2 1 lst)))
</code></p>

<p>It breaks list to pairs, and select max from each pair.
For example, <code>[8 5 9 3]</code> we split to <code>[[8 5] [5 9] [9 3]]</code>
and select max from each sublist <code>[8 9 9]</code>.</p>

<p>Just add this list to previous one</p>

<p><code>clojure
(defn step-max [lst1 lst2]
  (map + (max-row lst1) lst2))
</code></p>

<p>One iteration of <code>step-max</code> creates smaller triangle with sums on the bottom row.
But we need only one number.</p>

<p>Correct, <code>reduce</code> is ideal!</p>

<p><code>clojure
(reduce step-max (reverse triangle))
</code></p>

<p>That’s it.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem018.clj">code</a></p>

<p><strong>P.S.</strong> Problem 067 can be solved with the same code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 017]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-017/"/>
    <updated>2013-04-09T21:13:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-017</id>
    <content type="html"><![CDATA[<blockquote>
  <p>If the numbers 1 to 5 are written out in words: one, two, three, four, five,
then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p>

  <p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=17">http://projecteuler.net/problem=17</a></p>

<!-- more -->

<p>To solve this problem we need some sort of mapping that defines association
between number and its string representation, e.g <code>123 = one hundred and twenty three</code>.</p>

<p>This can be done with maps in clojure in form <code>{:1 "one" :2 "two"}</code>.
But if pay more atention to this map, we see that key is a numeric value.
Exactly what plain arrays do.</p>

<p>Then we just define all mappings, obtain all arrays string elements, find their lengths and sum them.</p>

<p>One problem that providing mapping for each number between 1 and 1000 is a “bit” routine task, so we
need some formula to calculate representation instead of hardcoding it. We come to defining groups.</p>

<p>First group is just <em>first 20</em> numbers:</p>

<p><code>clojure
(def first20 ["one" "two" "three" "four" "five"
              "six" "seven" "eight" "nine" "ten"
              "eleven" "twelve" "thirteen" "fourteen" "fifteen"
              "sixteen" "seventeen" "eighteen" "nineteen"])
</code></p>

<p>Note: there is no “zero” as we don’t use it in spoken language.</p>

<p>Second group is numbers that divides 10:</p>

<p><code>clojure
(def decas ["" "ten" "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty" "ninety"])
</code></p>

<p>Note: empty first element here is used to reduce additional check. Its length is 0, that has no effect at all.</p>

<p>And the last ones are three used values:</p>

<p><code>clojure
(def h "hundred")
(def t "thousand")
(def a "and")
</code></p>

<p>The basic function will calculate the length string representation of some number.
Let’s call it <code>word-length</code>.</p>

<p><code>clojure
(defn word-length [n]
  (cond (= n 1000) (+ (count t) (count (nth first20 1)))
        (&lt; n 100)
        (let [q (quot n 10) m (mod n 10)
              d (count (nth decas q))]
          (if (zero? m) d
              (if (&lt; q 2) (count (nth first20 (dec (+ m (* 10 q)))))
                  (+ d (count (nth first20 (dec m)))))))
        (&lt; n 1000)
        (let [q (quot n 100) m (mod n 100)]
          (if (zero? m) (+ (word-length q) (count h))
              (+ (count a) (count h) (word-length q) (word-length m))))))
</code></p>

<p>Little explanation:</p>

<ul>
  <li>If number is <code>1000</code> then the length of string “one” + “thousand”, 11.</li>
  <li>If number is lower than <code>100</code> then extract its decade part. If there is no
reminder for division by 10, the length is length of that decade part.</li>
  <li>Otherwise, if number in <code>first20</code>, length taken from array <code>first20</code>.</li>
  <li>Otherwise the length is decade part plus remainder.</li>
  <li>If number is lower than <code>1000</code> then extract hundred part. If there is no
reminder for division by 100, the length is “hundred” plus number of hundreds.</li>
  <li>Otherwise, the length is “hundred” plus number of hundreds, plus the word “and” and
recursively calculate the length of remainder, which is lower than <code>100</code>.</li>
</ul>

<p>Awful word-presentation of algorithm, because of… Reading code is much simpler, I know.</p>

<p>And the last part just sum up all word-lengths:</p>

<p><code>clojure
(reduce + (map word-length (range 1 1001)))
</code></p>

<p>Check the code <a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem017.clj">here</a>.</p>

<p>P.S. In fact algorithm is very simple, but needs some time to understand few branches.
By the way, the problem is little boring.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 016]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-016/"/>
    <updated>2013-03-05T01:31:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-016</id>
    <content type="html"><![CDATA[<blockquote>
  <p>2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.</p>

  <p>What is the sum of the digits of the number 2^1000 ?</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=16">http://projecteuler.net/problem=16</a></p>

<!-- more -->

<p>Are you kidding me?</p>

<ul>
  <li>Find 1000th <em>power of two</em></li>
  <li>Sum its digits</li>
</ul>

<p>In <a href="/blog/clojure-euler-problem-008/">Clojure Euler: Problem 008</a> we
learned how to sum digits in the number. Just gentle reminder:</p>

<p><code>clojure
(defn sum-of-digits [n]
  (reduce + (map #(- (int %) 48) (seq (str n)))))
</code></p>

<p>Now, let’s create sequence of powers of two:</p>

<p><code>clojure
(defn powers-of-2 []
  (iterate (partial * 2) 1))
</code></p>

<p>Unfortunately, this sequence throws <code>integer overflow</code> on the <code>64th</code> element.
We can fix that using <em>long arithmetics</em>, which known as <code>BigInteger</code> in Java.
Change <code>1</code> to <code>1N</code>.</p>

<p><code>clojure
(iterate (partial * 2) 1N)
</code></p>

<p>Another way is to use <strong>automatic promotion</strong> operator (<code>+'</code>, <code>*'</code>).
If result of some operation is not suitable for some type,
instead of invalid computation and runtime exception, clojure automatically promotes
the type to suitable one (<em>for example</em> <code>Long.MAX_VALUE +' 1</code> <em>works fine and produces
 correct result with type of</em> <code>BigInteger</code>):</p>

<p><code>clojure
(iterate (partial *' 2) 1)
</code></p>

<p>Choose <code>powers-of-2</code> that you prefer and final result will look like this:</p>

<p><code>clojure
(sum-of-digits (last (take 1001 (powers-of-2))))
</code></p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem016.clj">github</a></p>

<p><strong>P.S.</strong> Automatic promotion is a beatiful thing. But be aware about losing in
speed of calculations. Also, no way back. If promotion happened, <em>depromotion</em> won’t.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 015]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-015/"/>
    <updated>2013-02-19T00:38:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-015</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Starting in the top left corner of a 2 x 2 grid, there are 6 routes
(without backtracking) to the bottom right corner.</p>

  <p>How many routes are there through a 20 x 20 grid?</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=15">http://projecteuler.net/problem=15</a></p>

<!-- more -->

<p><img src="http://projecteuler.net/project/images/p_015.gif" alt="" /></p>

<p>Picture is always a huge help to find correct the solution.
Let’s see the pattern here, with another picture</p>

<p><em>Warning:</em> If you don’t understand art, don’t look at that picture.</p>

<p><img src="http://i.imgur.com/WNEQNxG.png" alt="" /></p>

<p>It’s a solution for 3 x 3 grid. We trying to process it by steps:</p>

<ul>
  <li>At the start we located at the top left corner <code>[0, 0]</code>. There is just one case
to be at the start so we put <code>1</code> to that point.</li>
  <li>Then we move either down <code>[1, 0]</code> or right <code>[0, 1]</code>, and we put <code>1</code>
on the edges of the second diagonal line.</li>
  <li>Obviously, the point <code>[1, 1]</code> we can reach either from <code>[0, 1]</code> or from <code>[1, 0]</code>,
so there are two routes, and so on.</li>
</ul>

<p>If you just output the numbers from each diagonal line you’ll get:</p>

<p>```
       1
      1 1
     1 2 1
    1 3 3 1</p>

<p>```</p>

<p>It’s famous <a href="http://en.wikipedia.org/wiki/Pascal%27s_triangle">Pascal’s triangle</a>.
Each element in this triangle obtained by sum of two closest elements from the upper row.</p>

<p>To get desired result we need to sum these numbers again, until we get one number.
But it’s also numbers from Pascal’s triangle.</p>

<p><code>
    1   3   3   1
      4   6   4
       10  10
         20
</code></p>

<p>We can treat Pascal’s triangle as a sequence, and each row is an element. Then the
following function calculates next row:</p>

<p><code>clojure
(defn routes-extend [lst]
  (let [size (count lst)]
    (for [i (range (inc size))]
      (if (or (= 0 i) (= size i)) 1
        (+ (nth lst (dec i)) (nth lst i))))))
</code></p>

<p>Usage:</p>

<p><code>
(routes-extend [1]) =&gt; [1 1]
(routes-extend [1 1]) =&gt; [1 2 1]
</code></p>

<p>Now we can build infinite sequence of Pascal’s triangle rows:</p>

<p><code>clojure
(iterate routes-extend [1])
</code></p>

<p>For <code>3 x 3</code> grid we had 7 diagonals, each of them represented one row.
Take a guess. For <code>n x n</code> grid we need to get <code>2 * n + 1</code> row. And take it
middle element, which, of course, will be with the index <code>n</code>.</p>

<p>That’s the final solution:</p>

<p><code>clojure
(let [n 20 d (inc (* n 2))]
  (nth (last (take d (iterate routes-extend [1]))) n))
</code></p>

<p>Problem solved.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem015.clj">Code</a></p>

<p><strong>P.S</strong> Two points I want to admit here. First of all, drawing pictures
and trying to understand problem with pictures is a powerful technique that must be
used for every problem.</p>

<p>Second of all, you can see that our algorithm has complexity of <code>O(n^2)</code>. But ideal
solution is <code>O(1)</code> with usage <a href="http://en.wikipedia.org/wiki/Binomial_coefficient">binomial coefficient</a>
<code>(2*n, n)</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 014]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-014/"/>
    <updated>2013-02-16T01:08:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-014</id>
    <content type="html"><![CDATA[<blockquote>
  <p>Which starting number, under one million, produces the longest Collatz chain?</p>
</blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=14">http://projecteuler.net/problem=14</a></p>

<!-- more -->

<blockquote>
  <p>The following iterative sequence is defined for the set of positive integers:</p>

  <p>n → n/2 (n is even)</p>

  <p>n → 3n + 1 (n is odd)</p>

  <p>Using the rule above and starting with 13, we generate the following sequence:</p>

  <p>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p>

  <p>It can be seen that this sequence (starting at 13 and finishing at 1)
contains 10 terms. Although it has not been proved yet (Collatz Problem),
it is thought that all starting numbers finish at 1.</p>

  <p>Which starting number, under one million, produces the longest chain?</p>

  <p>NOTE: Once the chain starts the terms are allowed to go above one million.</p>
</blockquote>

<p>Sequences again.
So, first of all we need function to detect next collatz number.
It is pretty straightforward:</p>

<p><code>clojure
(defn collatz-next [n]
  (if (even? n) (/ n 2) (inc (* n 3))))
</code></p>

<p>Using this <em>next-element-generator</em> we can generate infinite collatz sequence,
starting from number <code>n</code>:</p>

<p><code>clojure
(iterate collatz-next n)
</code></p>

<p>But instead of infinite sequence, we stop processing when we reach <code>1</code> and calculate
count of collatz chain sequence:</p>

<p><code>clojure
(defn collatz-chain-length [n]
  (inc (count (take-while #(&gt; % 1) (iterate collatz-next n)))))
</code></p>

<p>Now we have almost all code logic and just use it: calculate collatz chain
for all numbers in range <code>[1..1000000]</code>, find maximum and output its index:</p>

<p><code>clojure
(first (reduce #(if (&gt; (second %1) (second %2)) %1 %2)
               (map #(list % (collatz-chain-length %)) (range 1 1000000))))
</code></p>

<p>Run it. Wait a minute. I mean minute <em>literally</em>.</p>

<p>The time of caclulation is slightly greater than <strong>one minute</strong> on my machine,
and I have no idea how to solve it another way.</p>

<p>I am sure there is a better algorithm than mine. But I don’t know it.
What I know is try to re-read problem definion if you are stuck. Especially that part:</p>

<blockquote>
  <p>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</p>
</blockquote>

<p>So, for <code>13</code> the chain length is <code>10</code>, for <code>40</code> is <code>9</code>, for <code>20</code> is <code>8</code>,…</p>

<p>Got it?</p>

<p>Each time we calculate length we perform <em>repeated calculation</em>. If we know
chain length of <code>13</code>, and whole its path to <code>1</code> we don’t need to calculate length
for <code>40</code>, <code>20</code> and so on.</p>

<p>So the optimization is <em>somehow to cache the results</em>. But at first we need to rewrite
it to have recursive solution.</p>

<p>Here the first (<em>and final</em>) version:</p>

<p><code>clojure
(defn collatz-chain-recursive [n]
  (if (= n 1) 1
      (inc (collatz-chain-recursive (collatz-next n)))))
</code></p>

<p>Recursion is impressive at the point that its implementation
almost exactly follows the problem definition. It is easy to understand.</p>

<p>But, as you may notice our implementation not
<a href="http://en.wikipedia.org/wiki/Tail_call">tail-recursive</a> so we can
have troubles. Do not think about it unless we actually have them.</p>

<p>For the sake of fun let’s run this function instead of previous to
obtain the results.</p>

<p><strong>20 seconds</strong>, it is great. I even don’t think that
this simple recursive function gives such boost in performance.</p>

<p>One little tweak in result function:</p>

<p><code>clojure
(first
  (apply max-key second
         (map #(list % (collatz-chain-recursive %)) (range 1 1000000))))
</code></p>

<p>And we have <strong>~12 seconds</strong>.</p>

<p>Unexpected “The End”. Yeah, I love The Doors.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem014.clj">code-code</a></p>

<p><strong>P.S.</strong> I really wanted to explain technique called
<a href="http://en.wikipedia.org/wiki/Memoization">memoization</a> and
simple clojure function <a href="http://clojuredocs.org/clojure_core/clojure.core/memoize">memoize</a>,
but seems that caching result doesn’t have much sense here because
12 seconds is acceptable. We will have chance to introduce
memoization later, where it will be more useful. By the way, I am <em>lazy</em>.</p>
]]></content>
  </entry>
  
</feed>
