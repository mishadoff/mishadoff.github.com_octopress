<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: project-euler | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/project-euler/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2012-12-11T19:56:35+02:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 009]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-009/"/>
    <updated>2012-12-11T17:41:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-009</id>
    <content type="html"><![CDATA[<blockquote><p> A Pythagorean triplet is a set of three natural numbers, a &lt; b &lt; c, for which, a<sup>2</sup> + b<sup>2</sup> = c<sup>2</sup></p>

<p>For example, 3<sup>2</sup> + 4<sup>2</sup> = 9 + 16 = 25 = 5<sup>2</sup></p>

<p>There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=9">http://projecteuler.net/problem=9</a></p>

<!-- more -->


<p>Thinking about clever way to solve it...</p>

<p>Nothing good came up in your mind? Try bruteforce.</p>

<p>Again, the idea behind bruteforce for this problem to iterate over all possible values
for <code>a</code>, <code>b</code> and <code>c</code>, that sums to <code>1000</code> and compose Pythagorean triplet.
That's why we need predicate to test if three numbers compose triplet:</p>

<p><code>clojure
(defn is-triplet? [a b c]
  (= (+ (* a a) (* b b)) (* c c)))
</code></p>

<p>Then our bruteforce solution looks like this:</p>

<p>``` clojure
(first (for [a (range 1 1000) b (range 1 1000) c (range 1 1000)</p>

<pre><code>         :when (and (is-triplet? a b c) (= (+ a b c) 1000))] (* a b c)))
</code></pre>

<p>```</p>

<p>It finds the right solution, in ~45 seconds. Bad enough.</p>

<h3>Trick #1</h3>

<p>Do not iterate on <code>c</code> variable, because knowing <code>a</code> and <code>b</code> we always
can calculate <code>c = 1000 - a - b</code>.</p>

<p>Problem solution transformed into next one:</p>

<p>``` clojure
(first (for [a (range 1 1000) b (range 1 1000)</p>

<pre><code>         :let [c (- 1000 a b)]
         :when (is-triplet? a b c)] (* a b c)))
</code></pre>

<p>```</p>

<h3>Trick #2</h3>

<p>Use rule <code>a &lt; b &lt; c</code> from problem definition. Then our iteration will be:</p>

<p><code>clojure
(for [a (range 1 1000) b (range a (- 1000 a))])
</code></p>

<h3>Trick #3</h3>

<p><code>is-triplet?</code> predicate use 3 multiplications, addition and comparison.
We can add to <code>:when</code> section, predicate that compare <code>c</code> to <code>b</code>. This is also
slightly reduce number of <code>is-triplet?</code> execution.</p>

<p><code>clojure
:when (and (&gt; c b) (is-triplet? a b c))
</code></p>

<p>Now solution found in ~45 msecs. 1000 times faster. Not bad.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem009.clj">(apply str (reverse "buHtiG"))</a></p>

<p><strong>P.S.</strong> Unfortunately, there was nothing in this problem about new clojure
functions, programming and even problem was not challenging. But you see the way how
we solve it. We tried "bad" approach with knowing about all its disadvantages.
One more step and we improved it and got right solution. So it is not that bad
approach to try simple solution, even if it is wrong.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 008]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-008/"/>
    <updated>2012-11-27T22:53:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-008</id>
    <content type="html"><![CDATA[<blockquote><p>Find the greatest product of five consecutive digits in the 1000-digit number.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=8">http://projecteuler.net/problem=8</a></p>

<p><em>Large number under the cut.</em></p>

<!-- more -->


<p><code>
73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450
</code></p>

<p>Idea behind this problem is pretty straightforward:</p>

<ol>
<li>Init <code>maximum</code> with some small value, zero would be good.</li>
<li>Take first 5 digits, calculate the product.</li>
<li>If product is greater than our current <code>maximum</code>, reassign it.</li>
<li>Shift, to take other 5 digits, and back to the step 1.</li>
</ol>


<p>A simple optimization can be applied: if our last element of 5 digit group is zero,
then skip 5 shifts. But it's details.</p>

<p>Let's make our problem little harder to get more from clojure.</p>

<p>Assume that these digits stored in the file. First thing we need: to read the file.</p>

<p><code>clojure
(slurp "path/to/the/file")
</code></p>

<p><a href="http://clojuredocs.org/clojure_core/clojure.core/slurp">slurp</a> is the simplest
function to read file content (<em>In fact, not only files</em>).
It just returns string representation of the whole file.</p>

<p>Then we need to break one large string into symbols.</p>

<p><code>clojure
(seq "helloyo") =&gt; (\h \e \l \l \o \y \o)
</code></p>

<p><a href="http://clojuredocs.org/clojure_core/clojure.core/seq">seq</a> return a sequence with linear access
to collection. If applied to string, return sequence of characters.</p>

<p>But, there are some garbage in the file we don't want, new lines for example.</p>

<p><code>clojure
(remove #(= \newline %) [\h \e \l \l \o \newline \y \o])
</code></p>

<p>(<em>slash</em>) + something - represents character in clojure.
<code>\newline</code> is a new line, known as <code>\n</code> in other languages.</p>

<p>Now we have long sequence with all digits from file.
Need to get all consecutive groups with 5 letters.</p>

<p><code>clojure
(partition 5 1 [\h \e \l \l \o \y \o]) =&gt; [[\h \e \l \l \o] [\e \l \l \o \y] ... ]
</code></p>

<p><a href="http://clojuredocs.org/clojure_core/clojure.core/partition">partition</a>
is an excelent function for such tasks. We specify <code>5</code> - size of partition,
and <code>1</code> shift size. It generates all consecutive groups with 5 elements till the end.</p>

<p>Calulating the product for each group gives us the solution.</p>

<p><code>clojure
(reduce * [1 2 3 4])
</code></p>

<p>Not so fast.</p>

<p>You, probably, get <code>ClassCastException</code>.</p>

<p>After reading the file, we just get bunch of characters,
instead of digits in mathematical sense. And applied mathematical operation <code>*</code> to them.
So, simply speaking, <code>\1</code> is not <code>1</code>.</p>

<p>That's why we need to transform every digit character to it's actual digit value.</p>

<p><code>clojure
(map #(- (int %) 48) [\1 \2 \3]) =&gt; [1 2 3]
</code></p>

<p>This awful implementation do the work.</p>

<ul>
<li>Cast each character to int, get the <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>
representation for digit.</li>
<li>From each ASCII value we subtract <code>48</code> and get digit value.</li>
</ul>


<p>Applying <code>product</code> of digits defined earlier we get solution to this problem.</p>

<p>Again, full code on <a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem008.clj">GitHub</a>.</p>

<p><strong>P.S.</strong> <code>slurp</code> function very powerful and has may applications. You can specify encoding
for reading as you want or read whole html page by url. But it is also very dangerous function,
because reads all file contents to the memory and can take considerable amount of time. If you have
a large file, say 15GB, read it line by line with buffered reader. Also, note
<a href="http://clojuredocs.org/clojure_core/clojure.core/spit">spit</a> function. It is opposite to <code>slurp</code> -
writes string to the file.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 007]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-007/"/>
    <updated>2012-11-20T15:37:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-007</id>
    <content type="html"><![CDATA[<blockquote><p>By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.</p>

<p>What is the 10001st prime number?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=7">http://projecteuler.net/problem=7</a></p>

<!-- more -->


<p>It's also pretty clear problem to make you more familiar with prime numbers.
As I said in <a href="/blog/clojure-euler-problem-003">Clojure Euler: Problem 003</a>,
big amount of Project Euler problems devoted to prime numbers so it is <strong>MUST HAVE</strong> (<em>I don't like this phrase either</em>)</p>

<p>You need to implement by yourself effective prime number algorithm. And only after that use one from library.
As we do.</p>

<p><code>clojure
(:use [clojure.contrib.lazy-seqs :only (primes)])
</code></p>

<p>This line import just one symbol <code>primes</code> to your namespace. It's a prime numbers lazy sequence. Lazy sequences briefly covered
in <a href="/blog/clojure-euler-problem-002">Clojure Euler: Problem 002</a> or <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">Wikipedia article</a>,
that's enough for now.</p>

<p>Return to question.</p>

<blockquote><p>What is the 10001st prime number?</p></blockquote>

<p>No problem.</p>

<p><code>clojure
(last (take 10001 primes))
</code></p>

<p>Two lines of code: one for import, one for solution. What can be simpler?</p>

<p>Note, that <a href="http://clojuredocs.org/clojure_core/clojure.core/last">last</a> return last element of the sequence and works in linear time.</p>

<p>Another one problem solved in few <strike>seconds</strike> minutes.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem007.clj">GitHub</a></p>

<p><strong>P.S.</strong> Actually, I lied. In linked solution I use 6 lines of code: namespace declaration, use, <em>empty line</em>,
comment with executing time, function declaration and, finally, solution.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 006]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-006/"/>
    <updated>2012-11-17T14:05:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-006</id>
    <content type="html"><![CDATA[<blockquote><p>The sum of the squares of the first ten natural numbers is,</p>

<p>1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385</p>

<p>The square of the sum of the first ten natural numbers is,</p>

<p>(1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p>

<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 âˆ’ 385 = 2640.</p>

<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=6">http://projecteuler.net/problem=6</a></p>

<!-- more -->


<p>This problem is very simple, even simpler than previous one, that confirms fact that all Project Euler problems
are <strong>NOT</strong> in increasing complexity order. Ok, let's split our problem into two subproblems.</p>

<h3>Sum of the squares</h3>

<p>First, we need a square function:</p>

<p><code>clojure
(defn sqr [n] (* n n))
</code></p>

<p>Then, sum of squares of the first one hundred natural numbers we calculate with common <code>(reduce + list)</code> idiom:</p>

<p><code>clojure
(reduce + (map sqr (range 1 101)))
</code></p>

<h3>Square of the sum</h3>

<p>Just take a sum, and square it:</p>

<p><code>clojure
(sqr (reduce + (range 1 101)))
</code></p>

<h3>Bind all together</h3>

<p>We splitted our problem into two smaller, now is time to bind all. We can just subtract results obtained
but you see, that both of smaller solutions uses common piece of code <code>(range 1 101)</code>. Move it to <code>let</code> form.</p>

<p><code>clojure
(let [rn (range 1 101)]
  (- (sqr (reduce + rn)) (reduce + (map sqr rn)))))
</code></p>

<p>That' all. I've got result in less than millisecond.
Maybe there are some pitfalls in this problem (<em>e.g. integer overflow for larger ranges</em>)
but this most straightforward solution works fine.</p>

<p>Congratulations!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem006.clj">GitHub</a></p>

<p><strong>P.S.</strong> First time I solved this problem and was confused: <em>Where is the trick?</em> Seems nowhere.
That's why using most straightforward solution is often the best choice (<em>excluding obvious cases, of course</em>).
It has fast implementation, and if it fails, it fails fast.</p>

<p><strong>Fail Fast, Succeed Faster</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 005]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-005/"/>
    <updated>2012-11-09T19:01:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-005</id>
    <content type="html"><![CDATA[<blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>

<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=5">http://projecteuler.net/problem=5</a></p>

<!-- more -->


<p>It's a tricky problem. First look gives us straightforward solution:
Take a number, test if it evenly divisible by all of needed numbers, if yes - we good,
otherwise increment number and test again, and again, and again...</p>

<p>No, really, assume it's our function to test divisibility by all 20 numbers:</p>

<p>``` clojure
(defn evenly-divisible-by-20? [n]
  (zero? (reduce +</p>

<pre><code>(for [i (range 2 21)]
  (mod n i)))))
</code></pre>

<p>```</p>

<p>Awful implementation, but keeps the idea.
If sum of all remainders equals to zero, then every remainder equals to zero.
Now, using this function we write naive implementation:</p>

<p>``` clojure</p>

<pre><code>(first
  (drop-while #(not (evenly-divisible-by-20? %)) (iterate inc 1)))
</code></pre>

<p>```</p>

<p>Note, function <a href="http://clojuredocs.org/clojure_core/clojure.core/drop-while">drop-while</a>
similar to take-while, but skips values until they meet predicate condition.</p>

<p>Waiting for result? Take a cup of tea and wait a little. Still waiting? Wait a little more...</p>

<p>I did not post exact answer here, but result greater than 100 millions.
And obviously this linear algorithm will work considerable amount of time.
So, stop the execution and let's see at the problem from the other end.</p>

<p><em>What is the smallest number that evenly divisible by 1 and 2?</em>
Obviously 2.</p>

<p><em>What is the smallest number that evenly divisible by 2 and 3?</em>
A bit harder, but answer is 6.</p>

<p><em>What is the smallest number that evenly divisible by 4 and 5?</em>
20.</p>

<blockquote><p>Oh, it's just multiplication</p></blockquote>

<p>Unfortunately, no. Take numbers <code>4</code> and <code>6</code>, multiplication gives us <code>24</code> and it will be evenly divisible by <code>4</code> and <code>6</code>, but
this number is not the <em>smallest</em>. Snmallest number for this case will be <code>12</code>.</p>

<p>There is a function, that finds smallest number divisible by 2 different numbers.
This function called <a href="http://en.wikipedia.org/wiki/Least_common_multiple">Least Common Multiple</a> (<em>lcm</em>).
There are lot of different methods to calculate it, but we will use one that uses
<a href="http://en.wikipedia.org/wiki/Greatest_common_divisor">Greatest Common Divisor</a> (<em>gcd</em>)</p>

<p><img src="http://upload.wikimedia.org/math/5/b/3/5b3f3c62dd59cc5594af7b2ece3798fb.png" alt="" /></p>

<p>Where <em>gcd</em> calculated according to <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid's algorithm</a></p>

<p>``` clojure
(defn gcd [n k]
  (loop [a n b k]</p>

<pre><code>(if (zero? b) a (recur b (mod a b)))))
</code></pre>

<p>```</p>

<p>Using formula above, our <em>lcm</em> function will look like this:</p>

<p><code>clojure
(defn lcm [n k]
  (/ (abs (* n k)) (gcd n k)))
</code></p>

<p>You see, here we need <code>abs</code> function. Nothing hard to implement it, but if we remember
<a href="/blog/clojure-euler-problem-004">previous problem</a> there are was a reference
to <code>clojure.contrib.math</code> library. <code>abs</code> there and we can use it, just add to your namespace definition</p>

<p><code>clojure
(:use [clojure.contrib.math])
</code></p>

<p>Oh look, even <code>lcm</code> and <code>gcd</code> functions there. Excellent.</p>

<p>Now we can solve the problem. Remember the <code>reduce</code> function?</p>

<p><code>clojure
(reduce lcm (range 1 21))
</code></p>

<p>Actually, this one-liner is solution. And it gives us correct result.</p>

<p>What happens here? We iteratively (<em>with using reduce</em>) find the lcm for <code>1</code> and <code>2</code>,
then for result and <code>3</code>, for result and <code>4</code> and so on.</p>

<p><strong>Great!</strong> One more problem solved!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem005.clj">GitHub</a></p>

<p><strong>P.S.</strong> One lesson we learned here. Be aware about library functionality. It helps you
to solve problems and avoid coward mistakes. For example, we have incorrect above implementation
for <code>lcm</code> function. If we call <code>(lcm 0 0)</code> program fails with <code>DivideByZero</code> exception.
It still solve our problem, but in future uses can be an additional problem.
But in lib implementation this error is covered. And we can be sure that <em>almost always</em> libs contain much less
errors that your <em>new fancy wheel</em>.</p>
]]></content>
  </entry>
  
</feed>
