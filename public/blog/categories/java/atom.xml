<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2012-11-18T21:40:42+02:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Magic. Part 3: Finally]]></title>
    <link href="http://mishadoff.github.com/blog/java-magic-part-3-finally/"/>
    <updated>2012-11-18T19:39:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/java-magic-part-3-finally</id>
    <content type="html"><![CDATA[<p>Every experienced java programmer should know that <code>finally</code> block always executed. But is it true?</p>

<!-- more -->


<p>It depends on our definition of program execution. But, generally speaking, <strong>yes</strong>.</p>

<h3>Normal program execution</h3>

<p><em>Aha, look at this</em>, someone might retort:</p>

<p><code>java
try {
  System.exit(1);
} finally {
  System.out.println("I'm here, man");
}
</code></p>

<p><em>You just said, finally block always executed?</em></p>

<p>Well. In that case no, because we speaking about normal flow of program execution.
This is <em>abnormal</em>.</p>

<p>From the <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html">official tutorial</a></p>

<blockquote><p>Note: If the JVM exits while the try or catch code is being executed, then the finally block may not execute.</p></blockquote>

<p>Your counter question might be: <em>If second line of that code always exectued?</em></p>

<p><code>java
System.out.println("Line 1");
System.out.println("Line 2");
System.out.println("Line 3");
</code></p>

<p>Sure, because it's linear flow. Nothing can break...<strong>BANG</strong>...<code>Electricity unavailable. Program stopped.</code></p>

<p>What about this? It's also abnormal program execution, and we can't guarantee anything for 100%.
In fact, this is the same as <code>System.exit(1)</code> or <code>reset</code> button on your computer or whatever.</p>

<p>That's why, we are talking about <em>normal</em> program execution. Only <em>normal</em>.</p>

<blockquote><p>I said yes? I meant no!</p></blockquote>

<h3>Perpetuum Mobile</h3>

<p>Consider the following code:</p>

<p>``` java
try {
  while (true) {</p>

<pre><code>System.out.println("I print here some useful information");
</code></pre>

<p>  }
} finally {
  System.out.println("Let me run");
}
```</p>

<p>Will be the line <em>"Let me run"</em> printed? Maybe yes, if printing error to standard output appear. Almost always the answer is no.</p>

<p>In that case, there are no difference between simple statement and finally block. None of them will be executed, throw this example away.</p>

<h3>Threads</h3>

<p>What about threads? We know that execution flow controlled by threads and they can be interrupted.</p>

<p>Assume that we have thread that perform some work, and other thread kills first one right before finally block. Finally wasn't executed.</p>

<p>Assume that we have deadlock between two threads, right before finally line. The same thing.</p>

<p>From the <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html">same tutorial</a></p>

<blockquote><p>...if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues.</p></blockquote>

<p>So, we can treat thread like a program, and make one effective rule:</p>

<p><strong>Rule 1</strong>. Finally executes always, except the case where controlling program or thread was aborted.</p>

<h3>Finally we return</h3>

<p>Ok, now we know when finally is not executed. But do we know when finally is executed?</p>

<p>Consider the example:</p>

<p>``` java
int someFunc() {
  try {</p>

<pre><code>return 0;
</code></pre>

<p>  } finally {</p>

<pre><code>return 1;
</code></pre>

<p>  }
}
```</p>

<p>The result is obviously <code>1</code>. Just because <code>finally</code> is always executed.</p>

<p>Consider, next example:</p>

<p>``` java
int someFunc() {
  try {</p>

<pre><code>throw new RuntimeException();
</code></pre>

<p>  } finally {</p>

<pre><code>return 1;
</code></pre>

<p>  }
}
```</p>

<p>The result is <code>1</code> again. And it's a problem. We just lose the exception.
Such issue known as <em>exception swallowing</em>. It is very dangerous, because client's code expect either exception or some value, but it always get only value.</p>

<p>One more less imaginary example.</p>

<p>``` java
String deposit(int amount) throws DAOException {
  try {</p>

<pre><code>return dao.deposit(amount);
</code></pre>

<p>  } finally {</p>

<pre><code>return "OK";
</code></pre>

<p>  }
}
```</p>

<p>The logic behind <code>finally</code> is to have some default value, and our <code>deposit</code> method throws the <code>DAOException</code> where client code is
responsible for its handling. Unfortunately, perhaps compiler forces you to handle this <code>DAOException</code> it never occurs. And string "OK" will be returned.</p>

<p><strong>Rule 2</strong>. Never use <code>return</code> from <code>finally</code> block.</p>

<h3>Instead of conclusion</h3>

<p>A lot of programmers are aware about this common mistake. But some are not.
Maybe these two simple rules give you a tiny light on coward <code>finally</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Magic. Part 2: 0xCAFEBABE]]></title>
    <link href="http://mishadoff.github.com/blog/java-magic-part-2-0xcafebabe/"/>
    <updated>2012-10-31T19:42:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/java-magic-part-2-0xcafebabe</id>
    <content type="html"><![CDATA[<p>Did you know that all java classes start with the same 4 bytes. In hex it's <code>CAFEBABE</code>.</p>

<!-- more -->


<p>To make sure, create simple java file, call it <code>Hello.java</code>:</p>

<p>``` java
public class Hello {</p>

<pre><code>public static void main(String[] args) {
    System.out.println("Hell, O'World!");
}
</code></pre>

<p>}
```</p>

<p>Compile it by <code>javac Hello.java</code>, and open <code>Hello.class</code> with hex-editor (<code>M-x hexl-mode</code> for emacs)</p>

<p><img src="/images/cafebabe.png" title="cafebabe" alt="" /></p>

<p>James Gosling <a href="http://radio-weblogs.com/0100490/2003/01/28.html">explained</a> this:</p>

<blockquote><p>We used to go to lunch at a place called St Michael's Alley.
According to local legend, in the deep dark past, the Grateful Dead used to perform there before they made it big.
It was a pretty funky place that was definitely a Grateful Dead Kinda Place.
When Jerry died, they even put up a little Buddhist-esque shrine.
When we used to go there, we referred to the place as Cafe Dead.
Somewhere along the line it was noticed that this was a HEX number.
I was re-vamping some file format code and needed a couple of magic numbers: one for the persistent object file, and one for classes.
I used CAFEDEAD for the object file format, and in grepping for 4 character hex words that fit after "CAFE" (it seemed to be a good theme)
I hit on BABE and decided to use it. At that time, it didn't seem terribly important or destined to go anywhere but the trash-can of history.
So CAFEBABE became the class file format, and CAFEDEAD was the persistent object format. But the persistent object facility went away,
and along with it went the use of CAFEDEAD - it was eventually replaced by RMI.</p></blockquote>

<p><code>0xCAFEBABE</code> is <code>3405691582</code> in decimal.
If we sum all digits we get <code>43</code>. One more than <code>42</code> - <em>Ultimate Answer to the Life, the Universe, and Everything</em>.
By the way, <code>43</code> is a prime number. You see, magic everywhere. Even in the last sentence.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Magic. Part 1: java.net.URL]]></title>
    <link href="http://mishadoff.github.com/blog/java-magic-part-1-java-dot-net-dot-url/"/>
    <updated>2012-10-11T16:30:00+03:00</updated>
    <id>http://mishadoff.github.com/blog/java-magic-part-1-java-dot-net-dot-url</id>
    <content type="html"><![CDATA[<p>Recently, I found on reddit very interesting Java code snippet (slightly modified):</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">HashSet</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashSet</span><span class="o">();</span>
</span><span class='line'><span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="s">&quot;http://google.com&quot;</span><span class="o">));</span>
</span><span class='line'><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="s">&quot;http://google.com&quot;</span><span class="o">));</span>
</span><span class='line'><span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">60000</span><span class="o">);</span>
</span><span class='line'><span class="n">set</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="k">new</span> <span class="n">URL</span><span class="o">(</span><span class="s">&quot;http://google.com&quot;</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>What do you think the output for lines 3 and 5 will be?</p>

<!-- more -->


<p>Definitely not <code>true, true</code> if the question was asked. Think for two minutes.</p>

<p>Ok. In most cases it will be <code>true, false</code> because you have internet connection (<em>How else you can read this?</em>).
Turn off your network cable or wi-fi, and you'll get <code>true, true</code>.</p>

<p>The reason is in implementation of <code>hashCode()</code> and <code>equals()</code> methods for <code>URL</code> class.</p>

<p>Let's see how hashCode calculated:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">hashCode</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">hashCode</span><span class="o">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>  <span class="n">hashCode</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">hashCode</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">hashCode</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>We can see hashCode is an instance variable that calculates once. Makes sense, <code>URL</code> is <a href="http://en.wikipedia.org/wiki/Immutable_object">immutable</a>.
What is handler? It's an instance of one of <code>URLStreamHandler</code> subclasses, depends on protocol type (file, http, ftp), that have helper hashCode implementation.
Just look at <code>URL.hashCode()</code> javadoc:</p>

<blockquote><p>The hash code is based upon all the URL components relevant for URL comparison. As such, this operation is a blocking operation.</p></blockquote>

<p>Stop! <strong>BLOCKING OPERATION?!</strong></p>

<p><em>- Sorry, I couldn't check email yesterday due to hashCode calculation.</em></p>

<p>or even better</p>

<p><em>- No, mom, I can't watch porn, It's hashCode, you know.</em></p>

<p>Ok, let it be blocking. Another exciting part, that handler <strong>resolves host IP address</strong> for hashCode calculation.
Tries to resolve, to be honest. If it can not do this, it calculates hashCode based on host, which is <em>google.com</em> for our example.
Shit happens when IP is dynamic, or host have request balancer that also changes host IP.
In that case we got different hashCodes for one host name, and will have two (or even more) instances in HashSet. Not good at all.
By the way, hashCode and equals performance is terrible because of <code>URLStreamHandler</code> opens <code>URLConnection</code>. But it's another topic.</p>

<h3>How to avoid this?</h3>

<ul>
<li>Use <code>java.net.URI</code> instead of <code>java.net.URL</code>. It's not the best choice though, but have deterministic hashCode implementation.</li>
<li>Do not use <code>java.net.URL</code> in collections. Good option to maintain collection of String objects (that represent host name) and get URL when needed.</li>
<li>Disable your network adapter during hashCode calculation. (<em>It's a joke, but it helps</em>)</li>
<li>Use your own subclass of URLStreamHandler with proper implementation of hashCode.</li>
</ul>


<p>Finally, I'm pretty sure <code>java.net.URL</code> class has lot of useful applications. But not that way.</p>
]]></content>
  </entry>
  
</feed>
