<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | mishadoff thoughts]]></title>
  <link href="http://mishadoff.github.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://mishadoff.github.com/"/>
  <updated>2012-11-18T21:40:42+02:00</updated>
  <id>http://mishadoff.github.com/</id>
  <author>
    <name><![CDATA[mishadoff]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Magic. Part 3: Finally]]></title>
    <link href="http://mishadoff.github.com/blog/java-magic-part-3-finally/"/>
    <updated>2012-11-18T19:39:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/java-magic-part-3-finally</id>
    <content type="html"><![CDATA[<p>Every experienced java programmer should know that <code>finally</code> block always executed. But is it true?</p>

<!-- more -->


<p>It depends on our definition of program execution. But, generally speaking, <strong>yes</strong>.</p>

<h3>Normal program execution</h3>

<p><em>Aha, look at this</em>, someone might retort:</p>

<p><code>java
try {
  System.exit(1);
} finally {
  System.out.println("I'm here, man");
}
</code></p>

<p><em>You just said, finally block always executed?</em></p>

<p>Well. In that case no, because we speaking about normal flow of program execution.
This is <em>abnormal</em>.</p>

<p>From the <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html">official tutorial</a></p>

<blockquote><p>Note: If the JVM exits while the try or catch code is being executed, then the finally block may not execute.</p></blockquote>

<p>Your counter question might be: <em>If second line of that code always exectued?</em></p>

<p><code>java
System.out.println("Line 1");
System.out.println("Line 2");
System.out.println("Line 3");
</code></p>

<p>Sure, because it's linear flow. Nothing can break...<strong>BANG</strong>...<code>Electricity unavailable. Program stopped.</code></p>

<p>What about this? It's also abnormal program execution, and we can't guarantee anything for 100%.
In fact, this is the same as <code>System.exit(1)</code> or <code>reset</code> button on your computer or whatever.</p>

<p>That's why, we are talking about <em>normal</em> program execution. Only <em>normal</em>.</p>

<blockquote><p>I said yes? I meant no!</p></blockquote>

<h3>Perpetuum Mobile</h3>

<p>Consider the following code:</p>

<p>``` java
try {
  while (true) {</p>

<pre><code>System.out.println("I print here some useful information");
</code></pre>

<p>  }
} finally {
  System.out.println("Let me run");
}
```</p>

<p>Will be the line <em>"Let me run"</em> printed? Maybe yes, if printing error to standard output appear. Almost always the answer is no.</p>

<p>In that case, there are no difference between simple statement and finally block. None of them will be executed, throw this example away.</p>

<h3>Threads</h3>

<p>What about threads? We know that execution flow controlled by threads and they can be interrupted.</p>

<p>Assume that we have thread that perform some work, and other thread kills first one right before finally block. Finally wasn't executed.</p>

<p>Assume that we have deadlock between two threads, right before finally line. The same thing.</p>

<p>From the <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/finally.html">same tutorial</a></p>

<blockquote><p>...if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues.</p></blockquote>

<p>So, we can treat thread like a program, and make one effective rule:</p>

<p><strong>Rule 1</strong>. Finally executes always, except the case where controlling program or thread was aborted.</p>

<h3>Finally we return</h3>

<p>Ok, now we know when finally is not executed. But do we know when finally is executed?</p>

<p>Consider the example:</p>

<p>``` java
int someFunc() {
  try {</p>

<pre><code>return 0;
</code></pre>

<p>  } finally {</p>

<pre><code>return 1;
</code></pre>

<p>  }
}
```</p>

<p>The result is obviously <code>1</code>. Just because <code>finally</code> is always executed.</p>

<p>Consider, next example:</p>

<p>``` java
int someFunc() {
  try {</p>

<pre><code>throw new RuntimeException();
</code></pre>

<p>  } finally {</p>

<pre><code>return 1;
</code></pre>

<p>  }
}
```</p>

<p>The result is <code>1</code> again. And it's a problem. We just lose the exception.
Such issue known as <em>exception swallowing</em>. It is very dangerous, because client's code expect either exception or some value, but it always get only value.</p>

<p>One more less imaginary example.</p>

<p>``` java
String deposit(int amount) throws DAOException {
  try {</p>

<pre><code>return dao.deposit(amount);
</code></pre>

<p>  } finally {</p>

<pre><code>return "OK";
</code></pre>

<p>  }
}
```</p>

<p>The logic behind <code>finally</code> is to have some default value, and our <code>deposit</code> method throws the <code>DAOException</code> where client code is
responsible for its handling. Unfortunately, perhaps compiler forces you to handle this <code>DAOException</code> it never occurs. And string "OK" will be returned.</p>

<p><strong>Rule 2</strong>. Never use <code>return</code> from <code>finally</code> block.</p>

<h3>Instead of conclusion</h3>

<p>A lot of programmers are aware about this common mistake. But some are not.
Maybe these two simple rules give you a tiny light on coward <code>finally</code>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 006]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-006/"/>
    <updated>2012-11-17T14:05:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-006</id>
    <content type="html"><![CDATA[<blockquote><p>The sum of the squares of the first ten natural numbers is,</p>

<p>1<sup>2</sup> + 2<sup>2</sup> + ... + 10<sup>2</sup> = 385</p>

<p>The square of the sum of the first ten natural numbers is,</p>

<p>(1 + 2 + ... + 10)<sup>2</sup> = 55<sup>2</sup> = 3025</p>

<p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 âˆ’ 385 = 2640.</p>

<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=6">http://projecteuler.net/problem=6</a></p>

<!-- more -->


<p>This problem is very simple, even simpler than previous one, that confirms fact that all Project Euler problems
are <strong>NOT</strong> in increasing complexity order. Ok, let's split our problem into two subproblems.</p>

<h3>Sum of the squares</h3>

<p>First, we need a square function:</p>

<p><code>clojure
(defn sqr [n] (* n n))
</code></p>

<p>Then, sum of squares of the first one hundred natural numbers we calculate with common <code>(reduce + list)</code> idiom:</p>

<p><code>clojure
(reduce + (map sqr (range 1 101)))
</code></p>

<h3>Square of the sum</h3>

<p>Just take a sum, and square it:</p>

<p><code>clojure
(sqr (reduce + (range 1 101)))
</code></p>

<h3>Bind all together</h3>

<p>We splitted our problem into two smaller, now is time to bind all. We can just subtract results obtained
but you see, that both of smaller solutions uses common piece of code <code>(range 1 101)</code>. Move it to <code>let</code> form.</p>

<p><code>clojure
(let [rn (range 1 101)]
  (- (sqr (reduce + rn)) (reduce + (map sqr rn)))))
</code></p>

<p>That' all. I've got result in less than millisecond.
Maybe there are some pitfalls in this problem (<em>e.g. integer overflow for larger ranges</em>)
but this most straightforward solution works fine.</p>

<p>Congratulations!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem006.clj">GitHub</a></p>

<p><strong>P.S.</strong> First time I solved this problem and was confused: <em>Where is the trick?</em> Seems nowhere.
That's why using most straightforward solution is often the best choice (<em>excluding obvious cases, of course</em>).
It has fast implementation, and if it fails, it fails fast.</p>

<p><strong>Fail Fast, Succeed Faster</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 005]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-005/"/>
    <updated>2012-11-09T19:01:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-005</id>
    <content type="html"><![CDATA[<blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p>

<p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=5">http://projecteuler.net/problem=5</a></p>

<!-- more -->


<p>It's a tricky problem. First look gives us straightforward solution:
Take a number, test if it evenly divisible by all of needed numbers, if yes - we good,
otherwise increment number and test again, and again, and again...</p>

<p>No, really, assume it's our function to test divisibility by all 20 numbers:</p>

<p>``` clojure
(defn evenly-divisible-by-20? [n]
  (zero? (reduce +</p>

<pre><code>(for [i (range 2 21)]
  (mod n i)))))
</code></pre>

<p>```</p>

<p>Awful implementation, but keeps the idea.
If sum of all remainders equals to zero, then every remainder equals to zero.
Now, using this function we write naive implementation:</p>

<p>``` clojure</p>

<pre><code>(first
  (drop-while #(not (evenly-divisible-by-20? %)) (iterate inc 1)))
</code></pre>

<p>```</p>

<p>Note, function <a href="http://clojuredocs.org/clojure_core/clojure.core/drop-while">drop-while</a>
similar to take-while, but skips values until they meet predicate condition.</p>

<p>Waiting for result? Take a cup of tea and wait a little. Still waiting? Wait a little more...</p>

<p>I did not post exact answer here, but result greater than 100 millions.
And obviously this linear algorithm will work considerable amount of time.
So, stop the execution and let's see at the problem from the other end.</p>

<p><em>What is the smallest number that evenly divisible by 1 and 2?</em>
Obviously 2.</p>

<p><em>What is the smallest number that evenly divisible by 2 and 3?</em>
A bit harder, but answer is 6.</p>

<p><em>What is the smallest number that evenly divisible by 4 and 5?</em>
20.</p>

<blockquote><p>Oh, it's just multiplication</p></blockquote>

<p>Unfortunately, no. Take numbers <code>4</code> and <code>6</code>, multiplication gives us <code>24</code> and it will be evenly divisible by <code>4</code> and <code>6</code>, but
this number is not the <em>smallest</em>. Snmallest number for this case will be <code>12</code>.</p>

<p>There is a function, that finds smallest number divisible by 2 different numbers.
This function called <a href="http://en.wikipedia.org/wiki/Least_common_multiple">Least Common Multiple</a> (<em>lcm</em>).
There are lot of different methods to calculate it, but we will use one that uses
<a href="http://en.wikipedia.org/wiki/Greatest_common_divisor">Greatest Common Divisor</a> (<em>gcd</em>)</p>

<p><img src="http://upload.wikimedia.org/math/5/b/3/5b3f3c62dd59cc5594af7b2ece3798fb.png" alt="" /></p>

<p>Where <em>gcd</em> calculated according to <a href="http://en.wikipedia.org/wiki/Euclidean_algorithm">Euclid's algorithm</a></p>

<p>``` clojure
(defn gcd [n k]
  (loop [a n b k]</p>

<pre><code>(if (zero? b) a (recur b (mod a b)))))
</code></pre>

<p>```</p>

<p>Using formula above, our <em>lcm</em> function will look like this:</p>

<p><code>clojure
(defn lcm [n k]
  (/ (abs (* n k)) (gcd n k)))
</code></p>

<p>You see, here we need <code>abs</code> function. Nothing hard to implement it, but if we remember
<a href="/blog/clojure-euler-problem-004">previous problem</a> there are was a reference
to <code>clojure.contrib.math</code> library. <code>abs</code> there and we can use it, just add to your namespace definition</p>

<p><code>clojure
(:use [clojure.contrib.math])
</code></p>

<p>Oh look, even <code>lcm</code> and <code>gcd</code> functions there. Excellent.</p>

<p>Now we can solve the problem. Remember the <code>reduce</code> function?</p>

<p><code>clojure
(reduce lcm (range 1 21))
</code></p>

<p>Actually, this one-liner is solution. And it gives us correct result.</p>

<p>What happens here? We iteratively (<em>with using reduce</em>) find the lcm for <code>1</code> and <code>2</code>,
then for result and <code>3</code>, for result and <code>4</code> and so on.</p>

<p><strong>Great!</strong> One more problem solved!</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem005.clj">GitHub</a></p>

<p><strong>P.S.</strong> One lesson we learned here. Be aware about library functionality. It helps you
to solve problems and avoid coward mistakes. For example, we have incorrect above implementation
for <code>lcm</code> function. If we call <code>(lcm 0 0)</code> program fails with <code>DivideByZero</code> exception.
It still solve our problem, but in future uses can be an additional problem.
But in lib implementation this error is covered. And we can be sure that <em>almost always</em> libs contain much less
errors that your <em>new fancy wheel</em>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Magic. Part 2: 0xCAFEBABE]]></title>
    <link href="http://mishadoff.github.com/blog/java-magic-part-2-0xcafebabe/"/>
    <updated>2012-10-31T19:42:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/java-magic-part-2-0xcafebabe</id>
    <content type="html"><![CDATA[<p>Did you know that all java classes start with the same 4 bytes. In hex it's <code>CAFEBABE</code>.</p>

<!-- more -->


<p>To make sure, create simple java file, call it <code>Hello.java</code>:</p>

<p>``` java
public class Hello {</p>

<pre><code>public static void main(String[] args) {
    System.out.println("Hell, O'World!");
}
</code></pre>

<p>}
```</p>

<p>Compile it by <code>javac Hello.java</code>, and open <code>Hello.class</code> with hex-editor (<code>M-x hexl-mode</code> for emacs)</p>

<p><img src="/images/cafebabe.png" title="cafebabe" alt="" /></p>

<p>James Gosling <a href="http://radio-weblogs.com/0100490/2003/01/28.html">explained</a> this:</p>

<blockquote><p>We used to go to lunch at a place called St Michael's Alley.
According to local legend, in the deep dark past, the Grateful Dead used to perform there before they made it big.
It was a pretty funky place that was definitely a Grateful Dead Kinda Place.
When Jerry died, they even put up a little Buddhist-esque shrine.
When we used to go there, we referred to the place as Cafe Dead.
Somewhere along the line it was noticed that this was a HEX number.
I was re-vamping some file format code and needed a couple of magic numbers: one for the persistent object file, and one for classes.
I used CAFEDEAD for the object file format, and in grepping for 4 character hex words that fit after "CAFE" (it seemed to be a good theme)
I hit on BABE and decided to use it. At that time, it didn't seem terribly important or destined to go anywhere but the trash-can of history.
So CAFEBABE became the class file format, and CAFEDEAD was the persistent object format. But the persistent object facility went away,
and along with it went the use of CAFEDEAD - it was eventually replaced by RMI.</p></blockquote>

<p><code>0xCAFEBABE</code> is <code>3405691582</code> in decimal.
If we sum all digits we get <code>43</code>. One more than <code>42</code> - <em>Ultimate Answer to the Life, the Universe, and Everything</em>.
By the way, <code>43</code> is a prime number. You see, magic everywhere. Even in the last sentence.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Clojure Euler: Problem 003]]></title>
    <link href="http://mishadoff.github.com/blog/clojure-euler-problem-003/"/>
    <updated>2012-10-30T19:12:00+02:00</updated>
    <id>http://mishadoff.github.com/blog/clojure-euler-problem-003</id>
    <content type="html"><![CDATA[<blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.</p>

<p>What is the largest prime factor of the number 600851475143?</p></blockquote>

<p>Permalink: <a href="http://projecteuler.net/problem=3">http://projecteuler.net/problem=3</a></p>

<!-- more -->


<p>If you familiar with <a href="http://en.wikipedia.org/wiki/Prime_number">prime numbers</a>, you apparently know basic algorithms to find them,
if not, I advice to get familiar with it. There are lot of problems devoted to prime numbers on Project Euler. So, read 10 minutes about prime numbers, and go on.</p>

<p>In few words, prime number is a number starting from 2 that has no divisors except <em>1</em> and <em>itself</em>.
Exposing this logic on all numbers, we can simply find first prime numbers: <code>2, 3, 5, 7, 11, ...</code></p>

<p>To implement function that search for prime numbers we can implement predicate, that test whether number is prime or not:</p>

<p>``` clojure
(defn prime? [n]
   (= 2 (reduce +</p>

<pre><code>            (for [i (range 1 (inc n))]
              (if (= 0 (mod n i)) 1 0)))))
</code></pre>

<p>```</p>

<p>We iterate from 1 up to number and calculate reminder of division number by iteration counter.
If result is zero we return 1, otherwise we return 0.
For each number we get list with length of that number that marked with 1 for exact divisors.
For example for <code>6</code> list will be <code>(1 1 1 0 0 1)</code>, and for <code>7</code> list will be <code>(1 0 0 0 0 0 0 1)</code>.
Than we calculate sum of this list, which represents number of divisors. If count is two, that means number is prime.
This is simplest algorithm for testing prime number, built from prime number definition.</p>

<p>Performing small optimization you can see that in lists above, first and last elements are always equals to 1.
We can just drop them. Another optimization is we don't need go on when we found at least one remainder.
And I'm pretty sure you can find lot of flaws in this implementation.</p>

<p>But the most useful optimization is assumption that we don't need iterate to <code>n</code>, we can iterate to <code>sqrt(n)</code>.
This is based on fact that if we found some number <code>a</code> that is divisor of <code>n</code>, then there is another number <code>b = n / a</code>.
And <code>b</code> is also divisior of <code>n</code>. Little transformation gives us <code>a * b = n</code>. Assume <code>a &lt; b</code>, so if we found <code>a</code> we don't need to seek for <code>b</code>.
Number <code>n</code> is not prime. Maximum value of a achieved when <code>a</code> equals to <code>b</code>, <code>a^2 = n</code>, <code>a = sqrt(n)</code>.
This is reduce complexity of algorithm from <code>O(n)</code> to <code>O(sqrt(n))</code>.</p>

<p>In <a href="http://mishadoff.github.com/blog/clojure-euler-problem-002/">previous problem</a> we mentioned <code>clojure.contrib.lazy-seqs</code> package,
where we have primes lazy sequence. Let's use it!</p>

<p>Algorithm for solving our problem is following:</p>

<ol>
<li>Iterate through all prime number that less than square root of number</li>
<li>If this number is divisor add it to list</li>
<li>Find maximum from that list</li>
</ol>


<p>To transform statements above into clojure, we get:</p>

<p>``` clojure
(defn greatest-prime-of [number]
  (reduce max (filter #(zero? (mod number %))</p>

<pre><code>                  (take-while #(&lt; % (sqrt number)) primes))))
</code></pre>

<p>```</p>

<p>Something new here:</p>

<ul>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/max">max</a> - function that returns the greatest number of its arguments.</li>
<li><a href="http://clojuredocs.org/clojure_core/clojure.core/zero_q">zero?</a> - predicate that test whether number is equal to zero or not.
The same as <code>#(= 0 %)</code>.</li>
<li><a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/sqrt">sqrt</a> - function from <code>clojure.contrib.math</code>. Name is obvious.</li>
</ul>


<p>Now, we want to find result. Run the line</p>

<p><code>clojure
(greatest-prime-of 600851475143))
</code></p>

<p><strong>Congratulations!</strong> Third problem solved.</p>

<p><a href="https://github.com/mishadoff/project-euler/blob/master/src/project_euler/problem003.clj">GitHub</a> for lazy!</p>

<p><strong>P.S.</strong> Instead of using <code>clojure.contrib.math</code> for square root we could just write <code>(Math/sqrt n)</code> and got rid of dependency.
But for me is better to reuse something that was implemented in library. It's tested and worked, where your implementation can miss some point.
If you have time, dig more into <code>clojure.contrib.math</code>. It needs about 9 minutes. There are only 9 functions,
but you will probably reinvent them all the time:
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/expt">expt</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/abs">abs</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/sqrt">sqrt</a>,
<a href="http://clojuredocs.org/clojure_contrib/clojure.contrib.math/round">round</a> and others.</p>
]]></content>
  </entry>
  
</feed>
